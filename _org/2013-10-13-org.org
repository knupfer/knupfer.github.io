#+BEGIN_COMMENT
---
layout: post
title:  "Emacs Org-Mode"
categories: linux
---
#+END_COMMENT
#+name: paper
#+begin_src lilypond :exports none
\version "2.16.0"
#(ly:set-option 'resolution 140)
\paper{
indent=0\mm
line-width=90\mm
oddFooterMarkup=##f
oddHeaderMarkup=##f
bookTitleMarkup=##f
scoreTitleMarkup=##f
}
#+end_src


Org-Mode stellt eine der interessantesten Entdeckungen dar, die ich die letzten Monate gemacht habe. Org-Mode ist ein Modus, also eine Erweiterung, für den Texteditor Emacs. Org-Mode dient, wie der Name bereits impliziert, der Organisation.

* Outliner
Org-Mode bietet sehr elaborierte Outlinefähigkeiten. Hierarchien werden mit einer unterschiedlichen Anzahl an Sternen gezeigt.

#+BEGIN_SRC org
 * Erste Überschrift
 Text
 
 ** Unterüberschrift
 Text
 
 *** Unterunterüberschrift
 Text

 * Zweite Überschrift
#+END_SRC

Jede Unterüberschrift kann nur genau ein Elternteil (Überschrift) haben, jedoch kann jede Überschrift beliebig viele Kinder (Unterüberschriften) haben. Dies verhält sich also genau so, wie man es in einer geschriebenen Arbeit erwarten würde.

Um sich einen Überblick zu verschaffen und in seinem Dokument effizient zu navigieren, kann man einzelne Überschriften mit Hilfe der Tabulatortaste falten (ausblenden). Das obige Beispiel sieht gefaltet wie folgt aus:

#+BEGIN_SRC org
 * Erste Überschrift...
 * Zweite Überschrift
#+END_SRC

Zudem kann man ganze Hierarchiebäume verschieben und auch befördern bzw. degradieren.

* Todo-Listen
Es können Todo-Listen einfach erstellt werden und mit Tastenkürzel verändert werden, beispielsweise als erledigt markiert werden und automatisch einen Zeitstempel hinzufügen.

*** TODO offener Punkt
*** DONE abgeschlossener Punkt.
   CLOSED: [2013-10-13 Sun 12:31]

Und folgendermaßen sehen die beiden Punkte im Quelltext aus:

#+BEGIN_SRC org
 *** TODO offener Punkt
 *** DONE abgeschlossener Punkt.
    CLOSED: [2013-10-13 Sun 12:31]
#+END_SRC

** Agendas
Mit Hilfe dieser Todo-Listen können sich Projektpläne erstellen lassen, ferner können die Todos mit einer Frist versehen werden und die ganze Liste an Fristen dann in einen Terminkalender exportieren. Erledigte Punkte können per Tastenkürzel in eine andere Datei archiviert werden.

Ferner lassen sich per Befehl auch alle Todos eines Projektes, welches aus mehreren .org Dateien bestehen kann anzeigen und exportieren.

* Export
Da Org-Mode alles in simplen Textdateien speichert ist zwar einerseits die Kompatibilität und die Portabilität sehr hoch (man könnte Org-Mode-Dateien sogar mit Notepad erstellen), aber das Aussehen doch sehr limitiert.

Dementsprechend kann man in gängige, ästhetischere Formate exportieren:
1. LaTeX
   1. Entweder nur in die .tex Datei  
   2. Oder direkt in ein pdf, wobei die Datei mehrfach prozessiert wird und alle anderen dabei entstehenden Dateien automatisch gelöscht werden
2. Odt
3. Html
   1. Mit Head
   2. Ohne Head

Der Export ist so hervorragend, dass die resultierenden Pdfs direkt gedruckt werden können. Nach bedarf können einzelne Exportoptionen über Variablen verändert werden.

** LaTeX
LaTeX-Formeln können direkt in das Html exportiert werden. Hierfür muss keine besondere Notation bedacht werden, es ist die gleiche. Nur die $-Zeichen der LaTeX-Formelumgebung müssen mit der Formel anliegend notiert werden, um Verwechslungen mit dem Währungssymbol zu vermeiden. Als Beispiel der Laplace-Operator für multidimensionale Differentialrechnung: $$ \Delta=\sum_{k=1}^n \frac{\partial^2}{\partial x_k^2} $$

Im Quelltext sieht dies folgendermaßen aus:

#+BEGIN_SRC latex -r
$\Delta=\sum_{k=1}^n \frac{\partial^2} (ref:formel)
                          {\partial x_k^2}$
#+END_SRC

Diese komplette Homepage ist mit Org-Modes Html-Export gemacht. Ich exportiere nur den Body und lass das resultierende Html durch Jekyll automatisch prozessieren, danach ein push nach GitHub, und fertig!

** Sourceblöcke
Man kann jedoch nicht nur LaTeX-Code exportieren oder verwenden, sondern auch nahezu jede Programmier- und Markupsprache. So gab es weiter oben bereits mehrfach Codebeispiele in Org-Mode. Diese gibt man einfach folgendermaßen an:

#+BEGIN_SRC org
,#+BEGIN_SRC org
,* Testüberschrift
,#+END_SRC
#+END_SRC

Hier nun ein Beispiel eines Programmcodes in Python, welcher beim Export direkt ausgeführt wird und das Ergebnis automatisch in eine Tabelle überführt wird. Es wurde keine Zahl händisch in die Tabelle eingetragen.

#+BEGIN_SRC python :exports both
# Fibonacci-Reihe
x = [[0] * 5 for i in range(5)]
x[0][0] = 1
for i in range(25):
    x[i % 5][i // 5] += x[(i - 1) % 5][(i - 1) // 5]
    x[i % 5][i // 5] += x[(i - 2) % 5][(i - 2) // 5]
return x

#+END_SRC

#+RESULTS:
| 1 |  8 |  89 |  987 | 10946 |
| 1 | 13 | 144 | 1597 | 17711 |
| 2 | 21 | 233 | 2584 | 28657 |
| 3 | 34 | 377 | 4181 | 46368 |
| 5 | 55 | 610 | 6765 | 75025 |

Ferner ist es möglich, die Ergebnisse eines Sourceblocks für den Input eines anderen Sourceblocks zu verwenden. Dementsprechend können, ähnlich zu Shellscripten, Pipes zwischen verschiedenen Programmiersprachen gebaut werden. Das Ergebnis kann an jeder beliebigen Stelle im Dokument durch einen Platzhalter eingefügt werden, wodurch es möglich ist, Tabellen und Grafiken automatisch immer auf den aktuellen Datenstand darzustellen.

Man kann sich auch vorstellen, dass backupscripte die Datei automatisch bei jedem Export sichert, oder aber für eine Website nachbereitet. Es ist vor allem Erfreulich, dass man sich dadurch das mühselige übertragen von Daten in Tabellen (beispielsweise in LaTeX) ersparen kann.

#+BEGIN_SRC python :exports both

# Zahlensystemkonverter
Konvertierungszahl = 1000
Zahlenraum = 20
Zahlensystem = [[0] for i in range(Zahlenraum - 1)]
Resultat = [[''] * 2 for i in range(Zahlenraum - 1)]

for i in range(2, Zahlenraum + 1):
    Stelle = 0
    Zahlensystem[i-2][0] = Konvertierungszahl
    while Zahlensystem[i-2][0] > 0:
          Stelle += 1
          Zahlensystem[i-2].insert(1,chr(ord('0')
                  + (Zahlensystem[i - 2][0] % i)))
          Zahlensystem[i-2][0] //= i
    Zahlensystem[i - 2][0] = i    

for i in range(Zahlenraum - 1):
    Resultat[i][0] = Zahlensystem[i][0]
    for j in range(1, len(Zahlensystem[i])):
        Resultat[i][1] += str(Zahlensystem[i][j])

return Resultat

#+END_SRC

#+RESULTS:
|  2 | 1111101000 |
|  3 |    1101001 |
|  4 |      33220 |
|  5 |      13000 |
|  6 |       4344 |
|  7 |       2626 |
|  8 |       1750 |
|  9 |       1331 |
| 10 |       1000 |
| 11 |        82: |
| 12 |        6;4 |
| 13 |        5;< |
| 14 |        516 |
| 15 |        46: |
| 16 |        3>8 |
| 17 |        37> |
| 18 |        31: |
| 19 |        2>< |
| 20 |        2:0 |

*** Lilypond


#+begin_src lilypond :file /images/lily-beispiel.png :noweb yes :exports both
 <<paper>>
 
\language "deutsch"

\score {

<<
\new Voice = mel \relative c' { 
    \set Score.defaultBarType = "-"
    \time 2/2
    \clef "petrucci-c3"
    \set Score.skipBars = ##t
    \autoBeamOff
    \override NoteHead #'style = #'petrucci
    \override Staff.TimeSignature #'style = #'neomensural

    r2 e |
    e f2. e8 d c2 |
    c4 e f g2 f4 d e4. d8 d2 c4 |
    d2 
}

\new Lyrics \lyricsto mel { 
    Et a -- scen -- _ _ _ dit in coe -- _ _ _ _ _ _ _ lum, 
}
>>
  \layout {
    \context {
      \Staff
      \consists "Custos_engraver"
      \override Custos #'style = #'mensural
    }
  }
}

#+end_src

#+RESULTS:
[[file:/images/lily-beispiel.png]]
