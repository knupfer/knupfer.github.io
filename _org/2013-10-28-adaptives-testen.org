#+BEGIN_COMMENT
---
layout: post
title: Adaptives Testen
father: Wissenschaft
---
#+END_COMMENT
* Adaptives Testen
Beim adaptiven Testen werden die Möglichkeiten einer computerbasierten Testung in erweitertem Maße ausgenutzt.
Es wird innerhalb der Testung auf Grund der bereits beantworteten Fragen auf den Fähigkeitsgrad des Probanden geschätzt,
um ihm als nächstes eine Frage zu geben, die diesen reflektiert.

#+BEGIN_SRC ditaa :file /images/adaptiveditaa.png :exports code

+---------+   +-----------------+   +---------------+
| Item    |-->| Modellschätzung |-->|   Schätzung   |
| Antwort |   +-----------------+   | nächstes Item |
+---------+                         +---------------+
    ^                                       |
    |                                       |
    +---------------------------------------+

#+END_SRC 

** Kriterien
Wie genau die Frage ausgewählt wird hängt vornehmlich von den Zielen der Testung und den Nebenwirkungen, die man ggf. 
vermeiden möchte, ab. So wäre eine Frage, die der Proband mit einer Chance von 50% lösen kann ideal im Sinne eines 
Informationsgewinnes über den Probanden, da die Entropie maximal ist. 

Entropie stellt nicht nur Chaos, sondern auch Informationsdichte nach Shannon dar 
(vgl. [[http://de.wikipedia.org/wiki/Entropie_%28Informationstheorie%29][Wikipedia]]).
Die folgende Formel ergiebt die Entropie eines Ereignisses. Hierbei ist $n$ die Anzahl der Möglichkeiten und $p_i$ 
die jeweiligen Wahrscheinlichkeiten dieser (sich ausschließender) Möglichkeiten.

$$ H = - \sum_{i=1}^n p_i \cdot \log_2{p_i} $$

Betrachten wir ein binäres System, also nur Fragen die entweder vollständig falsch oder vollständig richtig beantwortet
werden können, so haben wir $n = 2$ und $p_2 = 1 - p_1$.

$$ H_2 = - p \cdot \log_2{p} - (1 - p) \cdot \log_2(1 - p) $$

Hieraus ergiebt sich, dass der Informationsgewinn bei $p = .5$ (im binären) maximal ist, da die Funktion symmetrisch ist und bei
$p = 0$ auf beiden Seiten $0$ ergibt.

$$ H_{max} = - 0.5 \cdot \log_2{0.5} - 0.5 \cdot \log_2{0.5} = 1 \mathrm{bit} $$

Hierbei ist $bit$ die übliche Einheit des Informationsgehaltes, auf Grund des $\log_2$. Es kann also ein Informationsgehalt
von 8 bit mit Hilfe eines bytes dargestellt werden, sprich mit 8 Nullen oder Einsen (z.B. 10101010).

#+BEGIN_SRC R :results output graphics :file /images/entropie.png :exports results
x = (0:100)/100
y = -x*log(x,2)-(1-x)*log(1-x,2)
plot(x,y,type="l",xlab=expression(Lösungswahrscheinlichkeit),ylab=expression("Entropie in bit"),  main="Entropieverteilung")
#+END_SRC

#+RESULTS:
[[file:/images/entropie.png]]

Mit der Formel für tatsächliche und für maximale Entropie kann die Redundanz ausgerechnet werden, welche in einer 
Testkonstruktion als Indikator für das Potential der Verbesserung durch ein adaptives Testverfahren benutzt werden kann.

$$ R = H_{max} - H $$

Somit kann im binären ein Test im idealfall um $R$ Fragen verkleinert werden, ohne an Informationen einzubüßen. 
Befinden sich im Test auch Fragen, die nicht binär sind, so verändert sich die Situation ein wenig.
Die Entropie wird stets maximal bei gleichen Wahrscheinlichkeiten. Gibt es nun bei einer Frage z.B. 0, 1, 2 oder 3 Punkte
gibt es eine maximale Entropie von $H_{max} = - \log_2{0.25} = 2 \mathrm{bit}$. Somit kann man einen Test auch um $R/2$ solcher
Fragen ohne Informationsverlust verkleinern.

*** Informationsgehalt in KoMus
Im August diesen Jahres habe ich mit Teilen des KoMus-Testes für musikalische Kompetenz eine empirische Studie
durchgeführt. Der KoMus-Test liegt in einem nicht adaptiven Format vor.

Interessant ist nun, die Überlegung, wieviel der Test von einer Überführung in einen adaptiven Test profitieren würde.

**** Durchschnittlicher Schüler
Der Simplizität halber können wir annehmen, dass ein Schüler genau die durchschnittlichen Lösungswahrscheinlichkeiten
für ein Item aufweist.

So muss man nur die Entropie mit den klassischen Itemschwierigkeiten der Items berechnen:

$$ H = \sum_{i=1}^n(- P_i \cdot \log_2{P_i} - (1 - P_i) \cdot \log_2(1 - P_i)) $$

Hierbei ist $P_i$ die klassische Itemschwierigkeit des Items $i$ und $n$ die Anzahl der Items. Ferner nimmt diese Formel
nur dichotome Items an.

**** Vierdimensional
Die Entropie ist jedoch eigentlich noch niedriger, wenn man die Schwierigkeiten adaptiv berechnet. Es handelt sich aber
immernoch um einen nicht adaptiven Test mit fester Reihenfolge. Es wird nur eine spezialform der Entropie, die bedingte
Entropie, benutzt (vgl. [[http://de.wikipedia.org/wiki/Bedingte_Entropie][Wikipedia]]).

Um die bedingte Lösungschance und somit auch die bedingte Entropie zu berechnen, werden alle Items der selben Dimension
einer logistisch binären Regression verwendet um die individuell Itemschwierigkeit eines Items der gleichen Dimension zu
berechnen.

$$ H = \sum_{D=1}^4(\sum_{i=1}^{n(D)}(- R \cdot \log_2{R}) - (1 - R) \cdot \log_2(1- R))$$
$$ R = Reg_2(P_{ivD}|\sum_{m=1}^{i(D)-1}P_{vmD}) $$

Hierbei ist $Reg_2(a|b)$ die binärlogistische Regression mit der AV $a$ und den UV $b$.

**** n-Dimensional
Das obige Modell nimmt jedoch an, dass die einzelnen Dimensionen nicht korrelieren und somit Itemantworten einer Dimension 
keine Information (also Entropiesenkung) über andere Dimensionen zulassen.

Dies ist aber eine nicht notwendige Einschränkung, die die Berechnung nicht nur weniger effektiv, sondern auch
komplizierter macht.

Berücksichtigen wir unabhängig von der Dimensionszugehörigkeit einfach alle bereits beantworteten Items, die einen
signifikanten Einfluss auf die Frage haben, haben wir im Endeffekt ein n-dimensionales Modell, wobei $n$ die Anzahl der
Fragen ist.

$$ H = \sum_{i=1}^n(- R \cdot \log_2{R} - (1 - R) \cdot \log_2(1 - R)) $$
$$ R = Reg_2(P_{iv}|\sum_{m=1}^{i-1}P_{vm}) $$

***** Probleme
Mögliche Probleme dieser Methode sind fehlende Datensätze, da die binärlogistische Regression normalerweise alle Fälle
ausschließt, die auch nur bei einem der UV keinen Wert hat. Durch den maßgeschneiderten Testweg ist es bei einem 
Itempool, der nicht komplett erschöpft wird, unmöglich diese Regression so durchzuführen. Dementsprechend müssen
andere Methoden gewählt werden, um mit fehlenden Daten umzugehen.

Eine Möglichkeit wäre, nicht vorhandene Antworten in den Datensätzen zu simulieren. Diese Simulation würde von den Items
die am sichersten geschätzt werden können zu den Items, die schwer geschätzt werden können stattfinden.

Der Grund hierfür liegt daran, dass bei einer sehr sicheren Schätzung der Entropiegehalt sich nur wenig ändert, 
aber es gleich viel mehr Personen gibt, die seriös für schwerere Schätzungen verwendet werden können, was diese
Schätzungen erleichtert.

Die Simulation sollte nach jeder Testung durchgeführt werden, um die Simulation mehr und mehr zu verbessern. Das dieses
Verfahren direkt einen Nutzen erbringt, sollte daran sichtbar sein, dass die Lösungen der alten Datensätze immer besser
retrospektiv vorhergesagt werden können und somit davon außgegangen werden kann, dass auch bei aktuellen Testungen
die Schätzungen besser sind und somit effektiver gemessen werden kann.

* Nicht adaptives Testen
 
* Adaptives Testen

** Umsetzung

*** Programmierung

**** Initialisierung
#+NAME: statistic
#+BEGIN_SRC R :session stat :exports both :results output :noweb yes
require(MASS)
library(multicore)
library(foreach)
library(doMC)
registerDoMC(8)

calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
komusmult = data.frame(read.table("data/komus.csv",header=TRUE, sep=','))
multifragen = array(which(sapply(komusmult, max) > 1))
multifragenalt = multifragen
komusmult[multifragen] = lapply(komusmult[multifragen],factor)

FUN.EntropieMC = function(x) {return(rowSums(-x*log(x+0.000000000001, 2)))}
FUN.EntropieMC.IND = function(x) {return(sum(-x*log(x+0.000000000001, 2)))}
FUN.Entropie = function(x) {return(-x*log(x, 2)-(1-x)*log(1-x, 2))}
FUN.Chances = function(x) {
    x[-multifragen] = lapply(x[-multifragen], predict, type="response")
    x[multifragen] = lapply(x[multifragen], predict, type="probs")
    return(x)
}
FUN.Chances.IND = function(x,y) {
    x[-multifragen] = lapply(x[-multifragen], predict, data = komusmult[y,], type="response")
    x[multifragen] = lapply(x[multifragen], predict, data = komusmult[y,], type="probs")
    return(x)
}
FUN.Entropietemp = function(x) {
    x[multifragen] = lapply(x[multifragen], FUN.EntropieMC)
    x[-multifragen] =lapply(x[-multifragen], FUN.Entropie)
    x = simplify2array(x)
    return(x)
}
FUN.Entropietemp.IND = function(x) {
    x[multifragen] = lapply(x[multifragen], FUN.EntropieMC.IND)
    x[-multifragen] =lapply(x[-multifragen], FUN.Entropie)
    x = simplify2array(x)
    return(x)
}

Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()
############
#items = length(komus)
#persons = length(komus[,1])
items = 10
persons = 5
############

EEE = data.frame(matrix(ncol = 1, nrow = items+1))
SumSD = data.frame(matrix(ncol = 1, nrow = items+1))
RestEntropie = data.frame(matrix(ncol = 1, nrow = items+1))
RestEntropieSD = data.frame(matrix(ncol = 1, nrow = items+1))
names(EEE) = 'kill'
names(SumSD) = 'kill'
names(RestEntropie) = 'kill'
names(RestEntropieSD) = 'kill'
#+END_SRC

#+RESULTS: statistic
#+begin_example
Lade nötiges Paket: MASS
foreach: simple, scalable parallel programming from Revolution Analytics
Use Revolution R for scalability, fault tolerance and more.
http://www.revolutionanalytics.com
Lade nötiges Paket: iterators
Lade nötiges Paket: parallel

Attache Paket: ‘parallel’

The following object(s) are masked from ‘package:multicore’:

    mclapply, mcparallel, pvec
#+end_example

**** Unbedingte und bedingte Entropie in normaler Reihenfolge
#+NAME: statistic1
#+BEGIN_SRC R :session stat :exports both :results output :noweb yes
############## Bedingte und undbedingte Entropie in normaler Reihenfolge
modell = NULL

if (1 %in% multifragen) {
    modell[[1]] = polr(reformulate('1', names(komusmult[1])), data = komusmult)
} else {
    modell[[1]] = glm(reformulate('1', names(komusmult[1])), data = komusmult, family = "binomial"(link=logit))
}

for (i in 2:items) {
    if (i %in% multifragen) {
        modell[[i]] = polr(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult)
    } else {
        modell[[i]] = glm(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult, family = "binomial"(link=logit))
    }
}
fitting = modell
<<fitting>>
chances = FUN.Chances(fitting)
#chances[-multifragen] = mclapply(fitting[-multifragen], predict, type="response")
#chances[multifragen] = mclapply(fitting[multifragen], predict, type="probs")

#Entropietemp = fitting
Entropietemp = FUN.Entropietemp(chances)
#Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC)
#Entropietemp[-multifragen] =lapply(chances[-multifragen], FUN.Entropie)
#Entropietemp = simplify2array(Entropietemp)

### Without relations ###
fitting = lapply(fitting, update, ~ 1)
chances2 = FUN.Chances(fitting)
#chances2[-multifragen] = mclapply(modell[-multifragen], predict, type="response")
#chances2[multifragen] = mclapply(modell[multifragen], predict, type="probs")
#Entropietemp2 = modell
Entropietemp2 = FUN.Entropietemp(chances2)
#Entropietemp2[multifragen] = lapply(chances2[multifragen], FUN.EntropieMC)
#Entropietemp2[-multifragen] =lapply(chances2[-multifragen], FUN.Entropie)
#Entropietemp2 = simplify2array(Entropietemp2)
#c(sapply(chances[multifragen], FUN.EntropieMC), sapply(fitting[-multifragen], predict, type="response"))


SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$bedunsort = c(0,SumSDtemp)


EEE$bedunsort = c(0,colMeans(Entropietemp))
EEE$unbedunsort = c(0,colMeans(Entropietemp2))
EEE$unbedsort = c(0,sort(colMeans(Entropietemp2), decreasing =TRUE))
Entropietemp2 = data.frame(Entropietemp2)
names(Entropietemp2) = names(komusmult[1:length(Entropietemp2)])
colMeans(Entropietemp2)
#names(colMeans(Entropietemp2)) = '1:50'
#colMeans(Entropietemp2)
#names(colMeans(Entropietemp2))
#+END_SRC

#+RESULTS: statistic1
#+begin_example
 Warnmeldung:
glm.fit: Angepasste Wahrscheinlichkeiten mit numerischem Wert 0 oder 1 aufgetreten
  X.D1124   D110a15   D110a25   D110a35   D113a16   D113a26   D113a56     D114a 
0.8125179 0.8862155 0.9456603 0.9575535 0.9962469 0.9855975 0.9974395 0.9984045 
    D114c     D114d   D115a23   D115c12    D11613  D118eMCe     D119a   D119b13 
0.9799954 0.9931771 0.9698397 0.6840384 0.9988017 0.8935711 0.8625279 0.9991421 
   D12012    D12022       D17     D1916     D1926    D21c12    D21c22      D21d 
0.8746787 0.8768193 0.9698397 0.9140593 0.8222671 0.9404757 0.9902738 2.0683589 
     D23b      D24a      D24b      D24e      D24h      D25a    D26a55     D26b1 
1.7420189 0.8075304 0.9716794 0.8899266 0.5084609 0.9955651 0.9350441 0.5446635 
    D26b2  D110b12b      D31a      D31b       D32      D34a      D36a      D36b 
0.7231802 0.9968716 0.8971493 0.8125179 2.3292271 2.7217771 0.9799954 0.9172474 
     D37b      D37c      D41d     D41f1     D41f2     D41f3     D4215     D4235 
0.8583391 0.9639651 2.4235069 0.9979504 0.9481606 0.9264294 0.9074902 0.9998228 
   D43a23    D43a33    D44a44    D45a14    D45a24    D45b26 
0.7704493 0.9172474 0.8540804 0.8785920 0.7591358 0.7293881
#+end_example

**** Bedingte, sortierte Entropie
#+NAME: statistic2
#+BEGIN_SRC R :session stat :exports both :results output :noweb yes
############### Bedingte Entropie in über den Durchschnitt sortierten Reihenfolge

modell = NULL
chances = NULL
fitting = NULL

############## sortierte Reihenfolge
for (i in 1:items) {
    if (i %in% multifragen) {
        modell[[i]] = polr(reformulate('1', names(komusmult[i])), data = komusmult)
    } else {
        modell[[i]] = glm(reformulate('1', names(komusmult[i])), data = komusmult, family = "binomial"(link=logit))
    }
}
chances = FUN.Chances(modell)
Entropietemp = FUN.Entropietemp(chances)
Entropietemp = data.frame(Entropietemp)
names(Entropietemp) = names(komusmult[1:length(Entropietemp)])
komus2 = komusmult[c(names(sort(colMeans(Entropietemp), decreasing=TRUE)))]
#########


names(sort(colMeans(Entropietemp), decreasing=TRUE))
multifragen.alt = multifragen
multifragen.alt
multifragen = which(names(komus2) %in% names(komusmult[multifragen.alt]))
modell = NULL
fitting = NULL
chances = NULL

if (1 %in% multifragen) {
    modell[[1]] = polr(reformulate('1', names(komus2[1])), data = komus2)
} else {
    modell[[1]] = glm(reformulate('1', names(komus2[1])), data = komus2, family = "binomial"(link=logit))
}

for (i in 2:items) {
    if (i %in% multifragen) {
        modell[[i]] = polr(reformulate(names(komus2[1:i-1]), names(komus2[i])), data = komus2)
    } else {
        modell[[i]] = glm(reformulate(names(komus2[1:i-1]), names(komus2[i])), data = komus2, family = "binomial"(link=logit))
    }
}
fitting = modell
<<fitting>>
chances = FUN.Chances(fitting)
#chances[-multifragen] = mclapply(fitting[-multifragen], predict, type="response")
#chances[multifragen] = mclapply(fitting[multifragen], predict, type="probs")

#Entropietemp = fitting
Entropietemp = FUN.Entropietemp(chances)
#Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC)
#Entropietemp[-multifragen] =lapply(chances[-multifragen], FUN.Entropie)
#Entropietemp = simplify2array(Entropietemp)

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$sortbed = c(0,SumSDtemp)

EEE$sortbed = c(0,colMeans(Entropietemp))


multifragen = multifragen.alt

#+END_SRC

#+RESULTS: statistic2
#+begin_example
 [1] "D34a"     "D41d"     "D32"      "D21d"     "D23b"     "D4235"   
 [7] "D119b13"  "D11613"   "D114a"    "D41f1"    "D113a56"  "D110b12b"
[13] "D113a16"  "D25a"     "D114d"    "D21c22"   "D113a26"  "D114c"   
[19] "D36a"     "D24b"     "D17"      "D115a23"  "D37c"     "D110a35" 
[25] "D41f2"    "D110a25"  "D21c12"   "D26a55"   "D41f3"    "D36b"    
[31] "D43a33"   "D1916"    "D4215"    "D31a"     "D118eMCe" "D24e"    
[37] "D110a15"  "D45a14"   "D12022"   "D12012"   "D119a"    "D37b"    
[43] "D44a44"   "D1926"    "X.D1124"  "D31b"     "D24a"     "D43a23"  
[49] "D45a24"   "D45b26"   "D26b2"    "D115c12"  "D26b1"    "D24h"
[1] 18 24 25 37 38 43
 Warnmeldungen:
1: glm.fit: fitted probabilities numerically 0 or 1 occurred 
2: glm.fit: fitted probabilities numerically 0 or 1 occurred 
3: glm.fit: Angepasste Wahrscheinlichkeiten mit numerischem Wert 0 oder 1 aufgetreten 
4: glm.fit: Angepasste Wahrscheinlichkeiten mit numerischem Wert 0 oder 1 aufgetreten 
5: glm.fit: Algorithmus konvergierte nicht 
6: glm.fit: Angepasste Wahrscheinlichkeiten mit numerischem Wert 0 oder 1 aufgetreten 
7: glm.fit: Angepasste Wahrscheinlichkeiten mit numerischem Wert 0 oder 1 aufgetreten
#+end_example

**** Durchschnittlich bedingtsortierte Entropie
#+NAME: statistic3
#+BEGIN_SRC R :session stat :exports both :results output :noweb yes
####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort

fragen = NULL
modell = NULL
Restentropietemp = NULL
multifragenalt = multifragen
############## sortierte Reihenfolge
for (i in 1:length(komusmult)) {
    if (i %in% multifragen) {
        fitting[[i]] = polr(reformulate('1', names(komusmult[i])), data = komusmult)
    } else {
        fitting[[i]] = glm(reformulate('1', names(komusmult[i])), data = komusmult, family = "binomial"(link=logit))
   }
}
#modell
chances = FUN.Chances(fitting)

Entropietemp = FUN.Entropietemp(chances)

fragen = which(names(komusmult[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komusmult))
fragen
#########
modell[[1]] = fitting[[fragen]]

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    multifragen = which(names(komusmult[-fragen]) %in% names(komusmult[multifragenalt]))


    for (j in 1:length(komusmult[-fragen])) {
        if (j %in% multifragen) {
            fitting[[j]] = polr(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult)
        } else {
            fitting[[j]] = glm(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult, family = "binomial"(link=logit))
        }
    }
    <<fitting>>
    chances = FUN.Chances(fitting)

    Entropietemp = FUN.Entropietemp(chances)
    Restentropietemp[[i-1]] = rowSums(Entropietemp)

    fragen = c(fragen, which(names(komusmult[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komusmult)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

if (length(komusmult) == items) {
    Restentropietemp[[items]] = Restentropietemp[[1]]*0
} else {
    fitting = NULL

    multifragen = which(names(komusmult[-fragen]) %in% names(komusmult[multifragenalt]))


    for (j in 1:length(komusmult[-fragen])) {
        if (j %in% multifragen) {
            fitting[[j]] = polr(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult)
        } else {
            fitting[[j]] = glm(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult, family = "binomial"(link=logit))
        }
    }
    <<fitting>>
    chances = FUN.Chances(fitting)
    Entropietemp = FUN.Entropietemp(chances)
    Restentropietemp[[items]] = rowSums(Entropietemp)
}
multifragen = which(fragen %in% multifragenalt)

Restentropietemp = simplify2array(Restentropietemp)

chances = FUN.Chances(modell)
Entropietemp = FUN.Entropietemp(chances)

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$durchschbedsort = c(0,SumSDtemp)
EEE$durchschbedsort = c(0,colMeans(Entropietemp))
RestEntropie$durchschbedsort = c(0,colMeans(Restentropietemp))
RestEntropieSD$durchschbedsort = c(0,apply(Restentropietemp, 2, sd))

#+END_SRC

#+RESULTS: statistic3
: [1] 38
:  Es gab 36 Warnungen (Anzeige mit warnings())
:  Warnmeldungen:
: 1: glm.fit: fitted probabilities numerically 0 or 1 occurred 
: 2: glm.fit: Angepasste Wahrscheinlichkeiten mit numerischem Wert 0 oder 1 aufgetreten 
: 3: glm.fit: Angepasste Wahrscheinlichkeiten mit numerischem Wert 0 oder 1 aufgetreten 
: 4: glm.fit: Angepasste Wahrscheinlichkeiten mit numerischem Wert 0 oder 1 aufgetreten 
: 5: glm.fit: Angepasste Wahrscheinlichkeiten mit numerischem Wert 0 oder 1 aufgetreten

**** Individuellbedingtsortierte Entropie
#+NAME: statistic4
#+BEGIN_SRC R :session stat :exports both :results output :noweb yes
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
Restentropietemp = NULL



for (j in 1:length(komus)) {
    fitting[[j]] = glm(reformulate('1', names(komus[j])), data = komus, family = "binomial"(link=logit))
}
<<fitting>>
chances = simplify2array(lapply(fitting, predict, komus[1,], type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
frageninit = which(names(komus[which((Entropietemp) == max((Entropietemp)))]) == names(komus))

modell[[1]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = frageninit
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL

        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        <<fitting>>
        chances = simplify2array(mclapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
    }

    if (length(komus) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        <<fitting>>
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }

    chances = simplify2array(mclapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

    return(c(Entropietemp, Restentropietemp))
})

Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]

SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsort = c(0,SumSDtemp)
EEE$indivbedsort = c(0,rowMeans(Entropieall))
RestEntropie$indivbedsort = c(0,rowMeans(Restentropietemp))
RestEntropieSD$indivbedsort = c(0,apply(Restentropietemp, 1, sd))
#+END_SRC

#+RESULTS: statistic4

**** Individuellbedingtsortierte Entropie mit Trennschärfe
#+NAME: statistic5
#+BEGIN_SRC R :session stat :exports both :results output :noweb yes
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL
Restentropietemp = NULL
Entropietemp = NULL
fitting = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}





for (j in 1:length(komus)) {
    fitting[[j]] = glm(reformulate('1', names(komus[j])), data = komus, family = "binomial"(link=logit))
}
<<fitting>>
chances = simplify2array(lapply(fitting, predict, komus[1,], type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information)
frageninit = which(names(komus[which((Entropietemp) == max((Entropietemp)))]) == names(komus))

 

modell[[1]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = frageninit
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        <<fitting>>
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
    }

    if (length(komus) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        <<fitting>>
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    
    return(c(Entropietemp, Restentropietemp))
})

Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsorttrenn = c(0,SumSDtemp )
EEE$indivbedsorttrenn = c(0,rowMeans(Entropieall))
RestEntropie$indivbedsorttrenn = c(0,rowMeans(Restentropietemp))
RestEntropieSD$indivbedsorttrenn = c(0,apply(Restentropietemp,1 ,sd))

#+END_SRC

#+RESULTS: statistic5

**** Experimenteller Code
#+BEGIN_SRC R :session stat :exports code :results output :noweb yes
calculationtime <- proc.time()



Entropieall = NULL
chances = NULL
Restentropietemp = NULL

fragen = NULL
modell = NULL
Restentropietemp = NULL
multifragen = multifragenalt
############## sortierte Reihenfolge
for (i in 1:length(komusmult)) {
    if (i %in% multifragen) {
        fitting[[i]] = polr(reformulate('1', names(komusmult[i])), data = komusmult)
    } else {
        fitting[[i]] = glm(reformulate('1', names(komusmult[i])), data = komusmult, family = "binomial"(link=logit))
   }
}
#modell
chances = fitting
chances[-multifragen] = lapply(fitting[-multifragen], predict, komusmult[1,], type="response")
chances[multifragen] = lapply(fitting[multifragen], predict, komusmult[1,], type="probs")
#chances = FUN.Chances.IND(fitting, 1)

Entropietemp = FUN.Entropietemp.IND(chances)

#Entropietemp

fragen = which(names(komusmult[which(Entropietemp == max(Entropietemp))]) == names(komusmult))
#fragen

######## bisher alles korrekt.
#########
modell[[1]] = fitting[[fragen]]

frageninit = fragen
fitting = NULL

Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
#foreach(k=1:2) %dopar% {
#k = 1
    fragen = frageninit
    Restentropie = NULL
    for (i in 2:items) {
        chances = NULL
        Entropietemp = NULL
        fitting = NULL

        multifragen = which(names(komusmult[-fragen]) %in% names(komusmult[multifragenalt]))

        for (j in 1:length(komusmult[-fragen])) {
            if (j %in% multifragen) {
                fitting[[j]] = polr(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult)
            } else {
                fitting[[j]] = glm(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult, family = "binomial"(link=logit))
            }
        }
        <<fitting>>
        chances = fitting
        chances[-multifragen] = lapply(fitting[-multifragen], predict, komusmult[k,], type="response")
        chances[multifragen] = lapply(fitting[multifragen], predict, komusmult[k,], type="probs")
        Entropietemp = chances

### Funktion kann nicht benutzt werden, da sie auf nicht manipulierte multifragen zugreift
        Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
        Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
        Entropietemp = simplify2array(Entropietemp)

        Restentropietemp[i-1] = sum(Entropietemp)

        fragen = c(fragen, which(names(komusmult[-fragen][which(Entropietemp == max(Entropietemp))]) == names(komusmult)))
        modell[[i]] = fitting[[which(Entropietemp == max(Entropietemp))]]
    }
#return(Restentropietemp)
#}

 
    if (length(komusmult) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
     
        multifragen = which(names(komusmult[-fragen]) %in% names(komusmult[multifragenalt]))
     
     
        for (j in 1:length(komusmult[-fragen])) {
            if (j %in% multifragen) {
                fitting[[j]] = polr(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult)
            } else {
                fitting[[j]] = glm(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult, family = "binomial"(link=logit))
            }
        }
        <<fitting>>


        chances = fitting
        chances[-multifragen] = lapply(fitting[-multifragen], predict, komusmult[k,], type="response")
        chances[multifragen] = lapply(fitting[multifragen], predict, komusmult[k,], type="probs")
        Entropietemp = chances

### Funktion kann nicht benutzt werden, da sie auf nicht manipulierte multifragen zugreift
        Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
        Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
        Entropietemp = simplify2array(Entropietemp)

        Restentropietemp[items] = sum(Entropietemp)
    }
    multifragen = which(fragen %in% multifragenalt)
 


        chances = modell
        chances[-multifragen] = lapply(modell[-multifragen], predict, komusmult[k,], type="response")
        chances[multifragen] = lapply(modell[multifragen], predict, komusmult[k,], type="probs")
        Entropietemp = chances

### Funktion kann nicht benutzt werden, da sie auf nicht manipulierte multifragen zugreift
        Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
        Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
        Entropietemp = simplify2array(Entropietemp)




    return(c(Entropietemp, Restentropietemp))    
})

Entropieall


#######
#    fragen = frageninit
#    for (i in 2:items) {
#        Entropietemp = NULL
#        fitting = NULL
# 
#        for (j in 1:length(komus[-fragen])) {
#            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
#        }
#        <<fitting>>
#        chances = simplify2array(mclapply(fitting, predict, komus[k,], type="response"))
#        Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
#        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
#        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
#        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
#    }
# 
#    if (length(komus) == items) {
#        Restentropietemp[items] = 0
#    } else {
#        fitting = NULL
#        for (j in 1:length(komus[-fragen])) {
#            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
#        }
#        <<fitting>>
#        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
#        Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
#    }
# 
#    chances = simplify2array(mclapply(modell, predict, komus[k,], type="response"))
#    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
# 
#    return(c(Entropietemp, Restentropietemp))
#})

Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]
 
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}
 
SumSD$indivbedsort = c(0,SumSDtemp)
EEE$indivbedsort = c(0,rowMeans(Entropieall))
RestEntropie$indivbedsort = c(0,rowMeans(Restentropietemp))
RestEntropieSD$indivbedsort = c(0,apply(Restentropietemp, 1, sd))

multifragen = multifragenalt
EEE
SumSD
RestEntropie
RestEntropieSD
#+END_SRC

#+RESULTS:
#+begin_example
        [,1]       [,2]
   2.7217771  2.7217771
   2.4274579  2.4274579
   2.1271021  2.1249267
   1.9680648  2.0162475
   1.3997216  1.7511812
1  0.9999897  0.9998829
1  0.9997862  0.9999659
1  0.9998893  0.9979677
1  0.9986637  0.9996245
1  0.9991479  0.9999405
  51.7849234 51.7849234
  49.1641347 48.7444946
  45.6663994 46.0860842
  43.5970694 43.5750404
  41.5954585 40.3970889
  41.3786697 39.4632445
  40.0007935 38.0384253
  39.4654650 36.3854259
  38.3512400 35.4432757
  37.0878996 34.3872873
   kill indivbedsort
1    NA    0.0000000
2    NA    2.7217771
3    NA    2.4274579
4    NA    2.1260144
5    NA    1.9921561
6    NA    1.5754514
7    NA    0.9999363
8    NA    0.9998761
9    NA    0.9989285
10   NA    0.9991441
11   NA    0.9995442
   kill indivbedsort
1    NA  0.000000000
2    NA  0.000000000
3    NA  0.000000000
4    NA  0.001538235
5    NA  0.032532074
6    NA  0.281051518
7    NA  0.280975943
8    NA  0.281103010
9    NA  0.279744233
10   NA  0.280423647
11   NA  0.280984111
   kill indivbedsort
1    NA      0.00000
2    NA     51.78492
3    NA     48.95431
4    NA     45.87624
5    NA     43.58605
6    NA     40.99627
7    NA     40.42096
8    NA     39.01961
9    NA     37.92545
10   NA     36.89726
11   NA     35.73759
   kill indivbedsort
1    NA   0.00000000
2    NA   0.00000000
3    NA   0.29673037
4    NA   0.29676195
5    NA   0.01557688
6    NA   0.84737529
7    NA   1.35441014
8    NA   1.38760389
9    NA   2.17791652
10   NA   2.05624123
11   NA   1.90962128
#+end_example

**** Schlussberechnungen
#+NAME: statisticend
#+BEGIN_SRC R :session stat :exports both :results output :noweb yes
################# Schlussberechnungen

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}

RestEntropie[1,] = sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2))

names(summe) = names(EEE)

if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}


benchmark

#+END_SRC

#+RESULTS: statisticend
: [1] 231.177  43.505  65.453

**** Formel für die Modellanpassung
#+NAME: fitting
#+BEGIN_SRC R
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
#+END_SRC

**** Benchmark
#+BEGIN_SRC R :session stat :noweb yes :results output graphics :file /images/benchmark.png :exports both
plot(benchmark, type="l", col=rgb(0,0,0), ann=F)
title(xlab="Durchlauf")
title(ylab="Dauer")
#+END_SRC

#+RESULTS:
[[file:/images/benchmark.png]]

**** Entropiegrafik
#+NAME: grafik
#+BEGIN_SRC R :session stat :noweb yes :results output graphics :file /images/entropie2.png :exports both

farbe = NULL
farbeSD = NULL
for (j in 1:(length(summe[1,]))) {
    r = runif(1,0.1,0.9)
    g = runif(1,0.1,0.9)
    b = runif(1,0.1,0.9)
    farbe[j] = rgb(r^1.2, g^1.2, b^1.2)
    farbeSD[j] = rgb(sqrt(r), sqrt(g), sqrt(b))
}

plot(0:(length(komusmult)), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbeSD[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbeSD[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[names(summe[i])], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbeSD[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbeSD[i])
    }
}

title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(length(komus)/4, length(komus), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

#+END_SRC

#+RESULTS: grafik
[[file:/images/entropie2.png]]
     
