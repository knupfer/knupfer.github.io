if (exists("Entropieall")) {
Entropieall = rbind(Entropieall, Entropietemp)
} else {
Entropieall = Entropietemp
}
print(Entropietemp)
print(Entropieall)
}

Entropie = cbind(Entropie, colMeans(Entropieall))

for (i in 1:length(Entropie[1,])) {
    for (j in 1:length(Entropie[,1])) {
        summe[j,i] = sum(Entropie[1:j,i])
    }
}


if (exists("benchmark")) {
benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
benchmark = (proc.time() - calculationtime)[3]
}


benchmark

/images/benchmark.png
'org_babel_R_eoe'
library(multicore)
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 


calculationtime <- proc.time()
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

items = length(komus[1:2])


modell[[1]] = glm(V1 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(colMeans(Entropietemp))
Entropie = cbind(Entropie,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
Entropie = cbind(Entropie,sort(Entropie[,2], decreasing = TRUE))
Entropie = cbind(Entropie,sort(Entropie[,1], decreasing = TRUE))

komus2 = komus[c(names(sort(Entropie[,2], decreasing = TRUE)))]
modell[[1]] = glm(V1 ~ 1, data = komus2, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus2[1:i-1]), names(komus2[i])), data = komus2, family = "binomial"(link=logit))
}
fitting = modell
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(Entropie, colMeans(Entropietemp))
Entropie = cbind(Entropie, sort(Entropie[,5], decreasing = TRUE))


fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
Entropie = cbind(Entropie, colMeans(Entropietemp))

fragen = c(44)
Entropieall = NULL
modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
for (k in 1:100) {
for (i in 2:items) {
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }
    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
}

chances = simplify2array(mclapply(modell, predict, komus[k,], type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
if (exists("Entropieall")) {
Entropieall = rbind(Entropieall, Entropietemp)
} else {
Entropieall = Entropietemp
}
print(Entropietemp)
print(Entropieall)
}

Entropie = cbind(Entropie, colMeans(Entropieall))

for (i in 1:length(Entropie[1,])) {
    for (j in 1:length(Entropie[,1])) {
        summe[j,i] = sum(Entropie[1:j,i])
    }
}


if (exists("benchmark")) {
benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
benchmark = (proc.time() - calculationtime)[3]
}


benchmark
'org_babel_R_eoe'
library(multicore)
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 


calculationtime <- proc.time()
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

items = length(komus[1:2])


modell[[1]] = glm(V1 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(colMeans(Entropietemp))
Entropie = cbind(Entropie,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
Entropie = cbind(Entropie,sort(Entropie[,2], decreasing = TRUE))
Entropie = cbind(Entropie,sort(Entropie[,1], decreasing = TRUE))

komus2 = komus[c(names(sort(Entropie[,2], decreasing = TRUE)))]
modell[[1]] = glm(V1 ~ 1, data = komus2, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus2[1:i-1]), names(komus2[i])), data = komus2, family = "binomial"(link=logit))
}
fitting = modell
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(Entropie, colMeans(Entropietemp))
Entropie = cbind(Entropie, sort(Entropie[,5], decreasing = TRUE))


fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
Entropie = cbind(Entropie, colMeans(Entropietemp))

fragen = c(44)
Entropieall = NULL
modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
for (k in 1:100) {
    for (i in 2:items) {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(mclapply(fitting, predict, komus[k,], type="response"))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
    }

    chances = simplify2array(mclapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    if (exists("Entropieall")) {
        Entropieall = rbind(Entropieall, Entropietemp)
    } else {
        Entropieall = Entropietemp
    }
}

Entropie = cbind(Entropie, colMeans(Entropieall))

for (i in 1:length(Entropie[1,])) {
    for (j in 1:length(Entropie[,1])) {
        summe[j,i] = sum(Entropie[1:j,i])
    }
}


if (exists("benchmark")) {
benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
benchmark = (proc.time() - calculationtime)[3]
}


benchmark
'org_babel_R_eoe'
png(filename="/images/entropie2.png")
plot(1:length(summe[,1]), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {

lines(summe[,i], col=rgb(runif(1,0,1),runif(1,0,1),runif(1,0,1)))
}
title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(1, length(summe[,1]), c(names(summe)), cex=0.8, lty=1)
dev.off()
'org_babel_R_eoe'
library(multicore)
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 


calculationtime <- proc.time()
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

items = length(komus[1:3])


modell[[1]] = glm(V1 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(colMeans(Entropietemp))
Entropie = cbind(Entropie,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
Entropie = cbind(Entropie,sort(Entropie[,2], decreasing = TRUE))
Entropie = cbind(Entropie,sort(Entropie[,1], decreasing = TRUE))

komus2 = komus[c(names(sort(Entropie[,2], decreasing = TRUE)))]
modell[[1]] = glm(V1 ~ 1, data = komus2, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus2[1:i-1]), names(komus2[i])), data = komus2, family = "binomial"(link=logit))
}
fitting = modell
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(Entropie, colMeans(Entropietemp))
Entropie = cbind(Entropie, sort(Entropie[,5], decreasing = TRUE))


fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
Entropie = cbind(Entropie, colMeans(Entropietemp))

fragen = c(44)
Entropieall = NULL
modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
for (k in 1:100) {
    for (i in 2:items) {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(mclapply(fitting, predict, komus[k,], type="response"))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
    }

    chances = simplify2array(mclapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    if (exists("Entropieall")) {
        Entropieall = rbind(Entropieall, Entropietemp)
    } else {
        Entropieall = Entropietemp
    }
}

Entropie = cbind(Entropie, colMeans(Entropieall))

for (i in 1:length(Entropie[1,])) {
    for (j in 1:length(Entropie[,1])) {
        summe[j,i] = sum(Entropie[1:j,i])
    }
}


if (exists("benchmark")) {
benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
benchmark = (proc.time() - calculationtime)[3]
}


benchmark
'org_babel_R_eoe'
png(filename="/images/entropie2.png")
plot(1:length(summe[,1]), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {

lines(summe[,i], col=rgb(runif(1,0,1),runif(1,0,1),runif(1,0,1)))
}
title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(1, length(summe[,1]), c(names(summe)), cex=0.8, lty=1)
dev.off()
'org_babel_R_eoe'
library(multicore)
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 


calculationtime <- proc.time()
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

items = length(komus[1:5])


modell[[1]] = glm(V1 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(colMeans(Entropietemp))
Entropie = cbind(Entropie,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
Entropie = cbind(Entropie,sort(Entropie[,2], decreasing = TRUE))
Entropie = cbind(Entropie,sort(Entropie[,1], decreasing = TRUE))

komus2 = komus[c(names(sort(Entropie[,2], decreasing = TRUE)))]
modell[[1]] = glm(V1 ~ 1, data = komus2, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus2[1:i-1]), names(komus2[i])), data = komus2, family = "binomial"(link=logit))
}
fitting = modell
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(Entropie, colMeans(Entropietemp))
Entropie = cbind(Entropie, sort(Entropie[,5], decreasing = TRUE))


fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
Entropie = cbind(Entropie, colMeans(Entropietemp))

fragen = c(44)
Entropieall = NULL
modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
for (k in 1:2) {
    for (i in 2:items) {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(mclapply(fitting, predict, komus[k,], type="response"))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
    }

    chances = simplify2array(mclapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    if (exists("Entropieall")) {
        Entropieall = rbind(Entropieall, Entropietemp)
    } else {
        Entropieall = Entropietemp
    }
}

Entropie = cbind(Entropie, colMeans(Entropieall))

for (i in 1:length(Entropie[1,])) {
    for (j in 1:length(Entropie[,1])) {
        summe[j,i] = sum(Entropie[1:j,i])
    }
}


if (exists("benchmark")) {
benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
benchmark = (proc.time() - calculationtime)[3]
}

komus[2,

benchmark
'org_babel_R_eoe'
calculationtime <- proc.time()
library(multicore)
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

############
items = length(komus[1:4])
############


############## Bedingte und undbedingte Entropie in normaler Reihenfolge
modell[[1]] = glm(V1 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(colMeans(Entropietemp))
Entropie = cbind(Entropie,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
Entropie = cbind(Entropie,sort(Entropie[,2], decreasing = TRUE))
Entropie = cbind(Entropie,sort(Entropie[,1], decreasing = TRUE))

############### Bedingte Entropie in über den Durchschnitt sortierten Reihenfolge
komus2 = komus[c(names(sort(Entropie[,2], decreasing = TRUE)))]
modell[[1]] = glm(V1 ~ 1, data = komus2, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus2[1:i-1]), names(komus2[i])), data = komus2, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(Entropie, colMeans(Entropietemp))
Entropie = cbind(Entropie, sort(Entropie[,5], decreasing = TRUE))


####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
Entropie = cbind(Entropie, colMeans(Entropietemp))

####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }
    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, komus[1,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
}

chances = simplify2array(mclapply(modell, predict, komus[1,], type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
Entropie = cbind(Entropie, Entropietemp)

################# Schlussberechnungen
for (i in 1:length(Entropie[1,])) {
    for (j in 1:length(Entropie[,1])) {
        summe[j,i] = sum(Entropie[1:j,i])
    }
}

if (exists("benchmark")) {
benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
benchmark = (proc.time() - calculationtime)[3]
}
benchmark
komus[1,]
'org_babel_R_eoe'
calculationtime <- proc.time()
library(multicore)
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

############
items = length(komus[1:4])
############


############## Bedingte und undbedingte Entropie in normaler Reihenfolge
modell[[1]] = glm(V1 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(colMeans(Entropietemp))
Entropie = cbind(Entropie,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
Entropie = cbind(Entropie,sort(Entropie[,2], decreasing = TRUE))
Entropie = cbind(Entropie,sort(Entropie[,1], decreasing = TRUE))

############### Bedingte Entropie in über den Durchschnitt sortierten Reihenfolge
komus2 = komus[c(names(sort(Entropie[,2], decreasing = TRUE)))]
modell[[1]] = glm(V1 ~ 1, data = komus2, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus2[1:i-1]), names(komus2[i])), data = komus2, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(Entropie, colMeans(Entropietemp))
Entropie = cbind(Entropie, sort(Entropie[,5], decreasing = TRUE))


####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
Entropie = cbind(Entropie, colMeans(Entropietemp))

####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }
    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, komus[1,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
}

chances = simplify2array(mclapply(modell, predict, komus[1,], type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
Entropie = cbind(Entropie, Entropietemp)

################# Schlussberechnungen
for (i in 1:length(Entropie[1,])) {
    for (j in 1:length(Entropie[,1])) {
        summe[j,i] = sum(Entropie[1:j,i])
    }
}

if (exists("benchmark")) {
benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
benchmark = (proc.time() - calculationtime)[3]
}
benchmark
komus[200,]
'org_babel_R_eoe'
calculationtime <- proc.time()
library(multicore)
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

############
items = length(komus[1:4])
############


############## Bedingte und undbedingte Entropie in normaler Reihenfolge
modell[[1]] = glm(V1 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(colMeans(Entropietemp))
Entropie = cbind(Entropie,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
Entropie = cbind(Entropie,sort(Entropie[,2], decreasing = TRUE))
Entropie = cbind(Entropie,sort(Entropie[,1], decreasing = TRUE))

############### Bedingte Entropie in über den Durchschnitt sortierten Reihenfolge
komus2 = komus[c(names(sort(Entropie[,2], decreasing = TRUE)))]
modell[[1]] = glm(V1 ~ 1, data = komus2, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus2[1:i-1]), names(komus2[i])), data = komus2, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(Entropie, colMeans(Entropietemp))
Entropie = cbind(Entropie, sort(Entropie[,5], decreasing = TRUE))


####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
Entropie = cbind(Entropie, colMeans(Entropietemp))

####### Bedingte Entropie, sortiert nach jeder individuellen Antwort

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
for (k in 1:4) {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL

        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(mclapply(fitting, predict, komus[k,], type="response"))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
    }

    chances = simplify2array(mclapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    if (exists("Entropieall")) {
        Entropieall = rbind(Entropieall, Entropietemp)
    } else {
        Entropieall = Entropietemp
    }
}

Entropie = cbind(Entropie, colMeans(Entropieall))

################# Schlussberechnungen
for (i in 1:length(Entropie[1,])) {
    for (j in 1:length(Entropie[,1])) {
        summe[j,i] = sum(Entropie[1:j,i])
    }
}

if (exists("benchmark")) {
benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
benchmark = (proc.time() - calculationtime)[3]
}
benchmark
'org_babel_R_eoe'
png(filename="/images/entropie2.png")
plot(1:length(summe[,1]), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
#farbe = 1 - (sum(summe[,i])/sum(1:length(summe[,1])))^5

lines(summe[,i], col=rgb(runif(1,0,1),runif(1,0,1),runif(1,0,1)))
}
title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
#legend(1, length(summe[,1]), c(names(summe)), cex=0.8, lty=1)
legend(1, length(summe[,1]), c(ttt), cex=0.8, lty=1)
dev.off()
'org_babel_R_eoe'
calculationtime <- proc.time()
library(multicore)
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

############
items = length(komus[1:4])
############


############## Bedingte und undbedingte Entropie in normaler Reihenfolge
modell[[1]] = glm(V1 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(colMeans(Entropietemp))
Entropie = cbind(Entropie,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
Entropie = cbind(Entropie,sort(Entropie[,2], decreasing = TRUE))
Entropie = cbind(Entropie,sort(Entropie[,1], decreasing = TRUE))

############### Bedingte Entropie in über den Durchschnitt sortierten Reihenfolge
komus2 = komus[c(names(sort(Entropie[,2], decreasing = TRUE)))]
modell[[1]] = glm(V1 ~ 1, data = komus2, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus2[1:i-1]), names(komus2[i])), data = komus2, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(Entropie, colMeans(Entropietemp))
Entropie = cbind(Entropie, sort(Entropie[,5], decreasing = TRUE))


####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
Entropie = cbind(Entropie, colMeans(Entropietemp))

####### Bedingte Entropie, sortiert nach jeder individuellen Antwort

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
for (k in 1:4) {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL

        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(mclapply(fitting, predict, komus[k,], type="response"))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
    }

    chances = simplify2array(mclapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    if (exists("Entropieall")) {
        Entropieall = rbind(Entropieall, Entropietemp)
    } else {
        Entropieall = Entropietemp
    }
}

Entropie = cbind(Entropie, colMeans(Entropieall))

################# Schlussberechnungen
for (i in 1:length(Entropie[1,])) {
    for (j in 1:length(Entropie[,1])) {
        summe[j,i] = sum(Entropie[1:j,i])
    }
}

if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}
benchmark
summe
'org_babel_R_eoe'
calculationtime <- proc.time()
library(multicore)
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

############
items = length(komus[1:4])
############


############## Bedingte und undbedingte Entropie in normaler Reihenfolge
modell[[1]] = glm(V1 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(colMeans(Entropietemp))
Entropie = cbind(Entropie,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
Entropie = cbind(Entropie,sort(Entropie[,2], decreasing = TRUE))
Entropie = cbind(Entropie,sort(Entropie[,1], decreasing = TRUE))

############### Bedingte Entropie in über den Durchschnitt sortierten Reihenfolge
komus2 = komus[c(names(sort(Entropie[,2], decreasing = TRUE)))]
modell[[1]] = glm(V1 ~ 1, data = komus2, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus2[1:i-1]), names(komus2[i])), data = komus2, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(Entropie, colMeans(Entropietemp))
Entropie = cbind(Entropie, sort(Entropie[,5], decreasing = TRUE))


####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
Entropie = cbind(Entropie, colMeans(Entropietemp))

####### Bedingte Entropie, sortiert nach jeder individuellen Antwort

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
for (k in 1:10) {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL

        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(mclapply(fitting, predict, komus[k,], type="response"))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
    }

    chances = simplify2array(mclapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    if (exists("Entropieall")) {
        Entropieall = rbind(Entropieall, Entropietemp)
    } else {
        Entropieall = Entropietemp
    }
}

Entropie = cbind(Entropie, colMeans(Entropieall))

################# Schlussberechnungen
for (i in 1:length(Entropie[1,])) {
    for (j in 1:length(Entropie[,1])) {
        summe[j,i] = sum(Entropie[1:j,i])
    }
}

if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}
benchmark
summe
'org_babel_R_eoe'
calculationtime <- proc.time()
library(multicore)
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

############
items = length(komus[1:3])
############


############## Bedingte und undbedingte Entropie in normaler Reihenfolge
modell[[1]] = glm(V1 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(colMeans(Entropietemp))
Entropie = cbind(Entropie,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
Entropie = cbind(Entropie,sort(Entropie[,2], decreasing = TRUE))
Entropie = cbind(Entropie,sort(Entropie[,1], decreasing = TRUE))

############### Bedingte Entropie in über den Durchschnitt sortierten Reihenfolge
komus2 = komus[c(names(sort(Entropie[,2], decreasing = TRUE)))]
modell[[1]] = glm(V1 ~ 1, data = komus2, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus2[1:i-1]), names(komus2[i])), data = komus2, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(Entropie, colMeans(Entropietemp))
Entropie = cbind(Entropie, sort(Entropie[,5], decreasing = TRUE))


####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
Entropie = cbind(Entropie, colMeans(Entropietemp))

####### Bedingte Entropie, sortiert nach jeder individuellen Antwort

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
for (k in 1:100) {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL

        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(mclapply(fitting, predict, komus[k,], type="response"))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
    }

    chances = simplify2array(mclapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    if (exists("Entropieall")) {
        Entropieall = rbind(Entropieall, Entropietemp)
    } else {
        Entropieall = Entropietemp
    }
}

Entropie = cbind(Entropie, colMeans(Entropieall))

################# Schlussberechnungen
for (i in 1:length(Entropie[1,])) {
    for (j in 1:length(Entropie[,1])) {
        summe[j,i] = sum(Entropie[1:j,i])
    }
}

if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}
benchmark
summe
'org_babel_R_eoe'
calculationtime <- proc.time()
library(multicore)
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

############
items = length(komus[1:3])
############


############## Bedingte und undbedingte Entropie in normaler Reihenfolge
modell[[1]] = glm(V1 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(colMeans(Entropietemp))
Entropie = cbind(Entropie,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
Entropie = cbind(Entropie,sort(Entropie[,2], decreasing = TRUE))
Entropie = cbind(Entropie,sort(Entropie[,1], decreasing = TRUE))

############### Bedingte Entropie in über den Durchschnitt sortierten Reihenfolge
komus2 = komus[c(names(sort(Entropie[,2], decreasing = TRUE)))]
modell[[1]] = glm(V1 ~ 1, data = komus2, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus2[1:i-1]), names(komus2[i])), data = komus2, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(Entropie, colMeans(Entropietemp))
Entropie = cbind(Entropie, sort(Entropie[,5], decreasing = TRUE))


####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
Entropie = cbind(Entropie, colMeans(Entropietemp))

####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
for (k in 1:10) {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL

        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(mclapply(fitting, predict, komus[k,], type="response"))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
    }

    chances = simplify2array(mclapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    if (exists("Entropieall")) {
        Entropieall = rbind(Entropieall, Entropietemp)
    } else {
        Entropieall = Entropietemp
    }
}

Entropietemp
Entropieall
colMeans(Entropieall)
Entropie = cbind(Entropie, colMeans(Entropieall))
Entropie
################# Schlussberechnungen
for (i in 1:length(Entropie[1,])) {
    for (j in 1:length(Entropie[,1])) {
        summe[j,i] = sum(Entropie[1:j,i])
    }
}

if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}
benchmark
summe
'org_babel_R_eoe'
calculationtime <- proc.time()
library(multicore)
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

############
items = length(komus[1:3])
############


############## Bedingte und undbedingte Entropie in normaler Reihenfolge
modell[[1]] = glm(V1 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(colMeans(Entropietemp))
Entropie = cbind(Entropie,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
Entropie = cbind(Entropie,sort(Entropie[,2], decreasing = TRUE))
Entropie = cbind(Entropie,sort(Entropie[,1], decreasing = TRUE))

############### Bedingte Entropie in über den Durchschnitt sortierten Reihenfolge
komus2 = komus[c(names(sort(Entropie[,2], decreasing = TRUE)))]
modell[[1]] = glm(V1 ~ 1, data = komus2, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus2[1:i-1]), names(komus2[i])), data = komus2, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(Entropie, colMeans(Entropietemp))
Entropie = cbind(Entropie, sort(Entropie[,5], decreasing = TRUE))


####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
Entropie = cbind(Entropie, colMeans(Entropietemp))

####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
for (k in 1:100) {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL

        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(mclapply(fitting, predict, komus[k,], type="response"))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
    }

    chances = simplify2array(mclapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    if (exists("Entropieall")) {
        Entropieall = rbind(Entropieall, Entropietemp)
    } else {
        Entropieall = Entropietemp
    }
}

Entropietemp
Entropieall
colMeans(Entropieall)
Entropie = cbind(Entropie, colMeans(Entropieall))
Entropie
################# Schlussberechnungen
for (i in 1:length(Entropie[1,])) {
    for (j in 1:length(Entropie[,1])) {
        summe[j,i] = sum(Entropie[1:j,i])
    }
}

if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}
benchmark
summe
'org_babel_R_eoe'
png(filename="/images/benchmark.png")
plot(benchmark, type="l", col=rgb(0,0,0), ann=F)
title(xlab="Dauer")
title(ylab="Durchlauf")
dev.off()
'org_babel_R_eoe'
png(filename="/images/entropie3.png")
calculationtime <- proc.time()
library(multicore)
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
for (bench in 1:15) {
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

############
items = length(komus[1:bench])
############


############## Bedingte und undbedingte Entropie in normaler Reihenfolge
modell[[1]] = glm(V1 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(colMeans(Entropietemp))
Entropie = cbind(Entropie,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
Entropie = cbind(Entropie,sort(Entropie[,2], decreasing = TRUE))
Entropie = cbind(Entropie,sort(Entropie[,1], decreasing = TRUE))

############### Bedingte Entropie in über den Durchschnitt sortierten Reihenfolge
komus2 = komus[c(names(sort(Entropie[,2], decreasing = TRUE)))]
modell[[1]] = glm(V1 ~ 1, data = komus2, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus2[1:i-1]), names(komus2[i])), data = komus2, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(Entropie, colMeans(Entropietemp))
Entropie = cbind(Entropie, sort(Entropie[,5], decreasing = TRUE))


####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
Entropie = cbind(Entropie, colMeans(Entropietemp))

####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
for (k in 1:3) {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL

        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(mclapply(fitting, predict, komus[k,], type="response"))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
    }

    chances = simplify2array(mclapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    if (exists("Entropieall")) {
        Entropieall = rbind(Entropieall, Entropietemp)
    } else {
        Entropieall = Entropietemp
    }
}

Entropie = cbind(Entropie, colMeans(Entropieall))

################# Schlussberechnungen
for (i in 1:length(Entropie[1,])) {
    for (j in 1:length(Entropie[,1])) {
        summe[j,i] = sum(Entropie[1:j,i])
    }
}

if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}

plot(1:length(summe[,1]), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
#farbe = 1 - (sum(summe[,i])/sum(1:length(summe[,1])))^5

lines(summe[,i], col=rgb(runif(1,0,1),runif(1,0,1),runif(1,0,1)))
}
title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
#legend(1, length(summe[,1]), c(names(summe)), cex=0.8, lty=1)
legend(1, length(summe[,1]), c(ttt), cex=0.8, lty=1)

}

dev.off()
'org_babel_R_eoe'
png(filename="/images/entropie3.png")
calculationtime <- proc.time()
library(multicore)
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
for (bench in 2:15) {
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

############
items = length(komus[1:bench])
############


############## Bedingte und undbedingte Entropie in normaler Reihenfolge
modell[[1]] = glm(V1 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(colMeans(Entropietemp))
Entropie = cbind(Entropie,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
Entropie = cbind(Entropie,sort(Entropie[,2], decreasing = TRUE))
Entropie = cbind(Entropie,sort(Entropie[,1], decreasing = TRUE))

############### Bedingte Entropie in über den Durchschnitt sortierten Reihenfolge
komus2 = komus[c(names(sort(Entropie[,2], decreasing = TRUE)))]
modell[[1]] = glm(V1 ~ 1, data = komus2, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus2[1:i-1]), names(komus2[i])), data = komus2, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(Entropie, colMeans(Entropietemp))
Entropie = cbind(Entropie, sort(Entropie[,5], decreasing = TRUE))


####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
Entropie = cbind(Entropie, colMeans(Entropietemp))

####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
for (k in 1:3) {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL

        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(mclapply(fitting, predict, komus[k,], type="response"))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
    }

    chances = simplify2array(mclapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    if (exists("Entropieall")) {
        Entropieall = rbind(Entropieall, Entropietemp)
    } else {
        Entropieall = Entropietemp
    }
}

Entropie = cbind(Entropie, colMeans(Entropieall))

################# Schlussberechnungen
for (i in 1:length(Entropie[1,])) {
    for (j in 1:length(Entropie[,1])) {
        summe[j,i] = sum(Entropie[1:j,i])
    }
}

if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}

plot(1:length(summe[,1]), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
#farbe = 1 - (sum(summe[,i])/sum(1:length(summe[,1])))^5

lines(summe[,i], col=rgb(runif(1,0,1),runif(1,0,1),runif(1,0,1)))
}
title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
#legend(1, length(summe[,1]), c(names(summe)), cex=0.8, lty=1)
legend(1, length(summe[,1]), c(ttt), cex=0.8, lty=1)

}

dev.off()
'org_babel_R_eoe'
png(filename="/images/entropie3.png")
calculationtime <- proc.time()
library(multicore)
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
for (bench in 2:15) {
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

############
items = length(komus[1:bench])
############


############## Bedingte und undbedingte Entropie in normaler Reihenfolge
modell[[1]] = glm(V1 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(colMeans(Entropietemp))
Entropie = cbind(Entropie,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
Entropie = cbind(Entropie,sort(Entropie[,2], decreasing = TRUE))
Entropie = cbind(Entropie,sort(Entropie[,1], decreasing = TRUE))

############### Bedingte Entropie in über den Durchschnitt sortierten Reihenfolge
komus2 = komus[c(names(sort(Entropie[,2], decreasing = TRUE)))]
modell[[1]] = glm(V1 ~ 1, data = komus2, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus2[1:i-1]), names(komus2[i])), data = komus2, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(Entropie, colMeans(Entropietemp))
Entropie = cbind(Entropie, sort(Entropie[,5], decreasing = TRUE))


####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
Entropie = cbind(Entropie, colMeans(Entropietemp))

####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
for (k in 1:3) {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL

        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(mclapply(fitting, predict, komus[k,], type="response"))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
    }

    chances = simplify2array(mclapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    if (exists("Entropieall")) {
        Entropieall = rbind(Entropieall, Entropietemp)
    } else {
        Entropieall = Entropietemp
    }
}

Entropie = cbind(Entropie, colMeans(Entropieall))

################# Schlussberechnungen
for (i in 1:length(Entropie[1,])) {
    for (j in 1:length(Entropie[,1])) {
        summe[j,i] = sum(Entropie[1:j,i])
    }
}

if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}


}
plot(1:length(summe[,1]), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
#farbe = 1 - (sum(summe[,i])/sum(1:length(summe[,1])))^5

lines(summe[,i], col=rgb(runif(1,0,1),runif(1,0,1),runif(1,0,1)))
}
title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
#legend(1, length(summe[,1]), c(names(summe)), cex=0.8, lty=1)
legend(1, length(summe[,1]), c(ttt), cex=0.8, lty=1)
dev.off()
'org_babel_R_eoe'
