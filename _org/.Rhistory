            chances[-multifragen] = lapply(fitting[-multifragen], predict, komusmult[k,], type="response")
            chances[multifragen] = lapply(fitting[multifragen], predict, komusmult[k,], type="probs")
            Entropietemp = chances

    ### Funktion kann nicht benutzt werden, da sie auf nicht manipulierte multifragen zugreift
            Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
            Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        }

        Restentropietemp[items] = sum(Entropietemp)
    }
    multifragen = 0
    multifragen = c(multifragen,which(fragen %in% multifragenalt))

    if (length(multifragen) == 1) {
        chances = modell
        chances = lapply(modell, predict, komusmult[k,], type="response")
        Entropietemp = chances
        Entropietemp = lapply(chances, FUN.Entropie)
        Entropietemp = simplify2array(Entropietemp)
    } else {
        multifragen = multifragen[2:length(multifragen)]
        chances = modell
        chances[-multifragen] = lapply(modell[-multifragen], predict, komusmult[k,], type="response")
        chances[multifragen] = lapply(modell[multifragen], predict, komusmult[k,], type="probs")
        Entropietemp = chances

        Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
        Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
        Entropietemp = simplify2array(Entropietemp)
    }

    return(c(Entropietemp, Restentropietemp))    
})

Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]
 
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}
 
SumSD$indivbedsortpred = c(0,SumSDtemp)
EEE$indivbedsortpred = c(0,rowMeans(Entropieall))
RestEntropie$indivbedsortpred = c(0,rowMeans(Restentropietemp))
RestEntropieSD$indivbedsortpred = c(0,apply(Restentropietemp, 1, sd))

multifragen = multifragenalt
EEE
SumSD
RestEntropie
RestEntropieSD
'org_babel_R_eoe'


fitting = NULL
Entropieall = NULL
chances = NULL
Restentropietemp = NULL
fragen = NULL
modell = NULL
Restentropietemp = NULL
multifragen = multifragenalt

for (i in 1:length(komusmult)) {
    if (i %in% multifragen) {
        fitting[[i]] = polr(reformulate('1', names(komusmult[i])), data = komusmult)
    } else {
        fitting[[i]] = glm(reformulate('1', names(komusmult[i])), data = komusmult, family = "binomial"(link=logit))
   }
}

chances = fitting
chances[-multifragen] = lapply(fitting[-multifragen], predict, komusmult[1,], type="response")
chances[multifragen] = lapply(fitting[multifragen], predict, komusmult[1,], type="probs")
Entropietemp = FUN.Entropietemp.IND(chances)
fragen = which(names(komusmult[which(Entropietemp == max(Entropietemp))]) == names(komusmult))
modell[[1]] = fitting[[fragen]]
frageninit = fragen
fitting = NULL
Restentropie2 = NULL

Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = frageninit
    Restentropie = NULL
    Restentropietemp2 = NULL

    for (i in 2:items) {
        chances = NULL
        Entropietemp = NULL
        fitting = NULL
        fitting2 = NULL
        fittingplus = NULL
        fittingminus = NULL
        Entropietemp2 = NULL
        multifragen = 0
        multifragen = c(multifragen,which(names(komusmult[-fragen]) %in% names(komusmult[multifragenalt])))
        for (j in 1:length(komusmult[-fragen])) {
            if (j %in% multifragen) {
                fitting[[j]] = polr(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult)
            } else {
                fitting[[j]] = glm(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult, family = "binomial"(link=logit))
            }
if (length(komusmult[-fragen]) > 1) {
            multifragen2 = c(0,which(names(komusmult[-fragen][-j]) %in% names(komusmult[multifragenalt])))
            for (n in 1:length(komusmult[-fragen][-j])) {
                if (n %in% multifragen2) {
                    fitting2[[n]] = polr(reformulate(names(c(komusmult[fragen], komusmult[-fragen][j])), names(komusmult[-fragen][-j][n])), data = komusmult)
                } else {
                    fitting2[[n]] = glm(reformulate(names(c(komusmult[fragen], komusmult[-fragen][j])), names(komusmult[-fragen][-j][n])), data = komusmult, family = "binomial"(link=logit))
                }
            }

        tempdata = komusmult[k,]
        tempdata[-fragen][j] = 0
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = fitting2
        if (length(multifragen2) == 1) {
            chances = lapply(fitting2, predict, tempdata, type="response")
            Entropietemp = chances
            Entropietemp = lapply(chances, FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        } else {
            multifragen2 = multifragen2[2:length(multifragen2)]
            chances[-multifragen2] = lapply(fitting2[-multifragen2], predict, tempdata, type="response")
            chances[multifragen2] = lapply(fitting2[multifragen2], predict, tempdata, type="probs")
            Entropietemp = chances
            Entropietemp[multifragen2] = lapply(chances[multifragen2], FUN.EntropieMC.IND)
            Entropietemp[-multifragen2] = lapply(chances[-multifragen2], FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        }

        Restentropietemp2[j] = sum(Entropietemp)
 #       modell[[i]] = fitting[[which(Entropietemp == max(Entropietemp))]]

if (length(fitting) > 1) {
        chances = fitting
multialt = multifragen
multifragen = multifragen[multifragen <= length(fitting)]
        if (length(multifragen) == 1) {
            chances = lapply(fitting, predict, komusmult[k,], type="response")
            Entropietemp = chances
            Entropietemp = lapply(chances, FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        } else {
            multifragen = multifragen[2:length(multifragen)]
            chances[-multifragen] = lapply(fitting[-multifragen], predict, komusmult[k,], type="response")
            chances[multifragen] = lapply(fitting[multifragen], predict, komusmult[k,], type="probs")
            Entropietemp = chances
            Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
            Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
            multifragen = c(0,multifragen)
        }
multifragen = multialt
        Restentropietemp[i-1] = sum(Entropietemp)
x11()
plot(Restentropietemp2 ~ 1:50, type='l')
lines(Restentropietemp) 
}



} else {
Restentropietemp2[j] = 0 
}



        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = fitting
        if (length(multifragen) == 1) {
            chances = lapply(fitting, predict, komusmult[k,], type="response")
            Entropietemp = chances
            Entropietemp = lapply(chances, FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        } else {
            multifragen = multifragen[2:length(multifragen)]
            chances[-multifragen] = lapply(fitting[-multifragen], predict, komusmult[k,], type="response")
            chances[multifragen] = lapply(fitting[multifragen], predict, komusmult[k,], type="probs")
            Entropietemp = chances
            Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
            Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        }

        Restentropietemp[i-1] = sum(Entropietemp)
        fragen = c(fragen, which(names(komusmult[-fragen][which(Restentropietemp2 == min(Restentropietemp2))]) == names(komusmult)))
        modell[[i]] = fitting[[which(Entropietemp == max(Entropietemp))]]
    }

    if (length(komusmult) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        multifragen = 0
        multifragen = c(0,which(names(komusmult[-fragen]) %in% names(komusmult[multifragenalt])))
        for (j in 1:length(komusmult[-fragen])) {
            if (j %in% multifragen) {
                fitting[[j]] = polr(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult)
            } else {
                fitting[[j]] = glm(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult, family = "binomial"(link=logit))
            }
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)

        if (length(multifragen) == 1) {
            chances = lapply(fitting, predict, komusmult[k,], type="response")
            Entropietemp = chances
            Entropietemp = lapply(chances, FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
     
        } else {
            multifragen = multifragen[2:length(multifragen)]
            chances[-multifragen] = lapply(fitting[-multifragen], predict, komusmult[k,], type="response")
            chances[multifragen] = lapply(fitting[multifragen], predict, komusmult[k,], type="probs")
            Entropietemp = chances

    ### Funktion kann nicht benutzt werden, da sie auf nicht manipulierte multifragen zugreift
            Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
            Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        }

        Restentropietemp[items] = sum(Entropietemp)
    }
    multifragen = 0
    multifragen = c(multifragen,which(fragen %in% multifragenalt))

    if (length(multifragen) == 1) {
        chances = modell
        chances = lapply(modell, predict, komusmult[k,], type="response")
        Entropietemp = chances
        Entropietemp = lapply(chances, FUN.Entropie)
        Entropietemp = simplify2array(Entropietemp)
    } else {
        multifragen = multifragen[2:length(multifragen)]
        chances = modell
        chances[-multifragen] = lapply(modell[-multifragen], predict, komusmult[k,], type="response")
        chances[multifragen] = lapply(modell[multifragen], predict, komusmult[k,], type="probs")
        Entropietemp = chances

        Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
        Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
        Entropietemp = simplify2array(Entropietemp)
    }

    return(c(Entropietemp, Restentropietemp))    
})

Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]
 
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}
 
SumSD$indivbedsortpred = c(0,SumSDtemp)
EEE$indivbedsortpred = c(0,rowMeans(Entropieall))
RestEntropie$indivbedsortpred = c(0,rowMeans(Restentropietemp))
RestEntropieSD$indivbedsortpred = c(0,apply(Restentropietemp, 1, sd))

multifragen = multifragenalt
EEE
SumSD
RestEntropie
RestEntropieSD
'org_babel_R_eoe'


fitting = NULL
Entropieall = NULL
chances = NULL
Restentropietemp = NULL
fragen = NULL
modell = NULL
Restentropietemp = NULL
multifragen = multifragenalt

for (i in 1:length(komusmult)) {
    if (i %in% multifragen) {
        fitting[[i]] = polr(reformulate('1', names(komusmult[i])), data = komusmult)
    } else {
        fitting[[i]] = glm(reformulate('1', names(komusmult[i])), data = komusmult, family = "binomial"(link=logit))
   }
}

chances = fitting
chances[-multifragen] = lapply(fitting[-multifragen], predict, komusmult[1,], type="response")
chances[multifragen] = lapply(fitting[multifragen], predict, komusmult[1,], type="probs")
Entropietemp = FUN.Entropietemp.IND(chances)
fragen = which(names(komusmult[which(Entropietemp == max(Entropietemp))]) == names(komusmult))
modell[[1]] = fitting[[fragen]]
frageninit = fragen
fitting = NULL
Restentropie2 = NULL

Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = frageninit
    Restentropie = NULL
    Restentropietemp2 = NULL

    for (i in 2:items) {
        chances = NULL
        Entropietemp = NULL
        fitting = NULL
        fitting2 = NULL
        fittingplus = NULL
        fittingminus = NULL
        Entropietemp2 = NULL
        multifragen = 0
        multifragen = c(multifragen,which(names(komusmult[-fragen]) %in% names(komusmult[multifragenalt])))
        for (j in 1:length(komusmult[-fragen])) {
            if (j %in% multifragen) {
                fitting[[j]] = polr(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult)
            } else {
                fitting[[j]] = glm(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult, family = "binomial"(link=logit))
            }
if (length(komusmult[-fragen]) > 1) {
            multifragen2 = c(0,which(names(komusmult[-fragen][-j]) %in% names(komusmult[multifragenalt])))
            for (n in 1:length(komusmult[-fragen][-j])) {
                if (n %in% multifragen2) {
                    fitting2[[n]] = polr(reformulate(names(c(komusmult[fragen], komusmult[-fragen][j])), names(komusmult[-fragen][-j][n])), data = komusmult)
                } else {
                    fitting2[[n]] = glm(reformulate(names(c(komusmult[fragen], komusmult[-fragen][j])), names(komusmult[-fragen][-j][n])), data = komusmult, family = "binomial"(link=logit))
                }
            }

        tempdata = komusmult[k,]
        tempdata[-fragen][j] = 0
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = fitting2
        if (length(multifragen2) == 1) {
            chances = lapply(fitting2, predict, tempdata, type="response")
            Entropietemp = chances
            Entropietemp = lapply(chances, FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        } else {
            multifragen2 = multifragen2[2:length(multifragen2)]
            chances[-multifragen2] = lapply(fitting2[-multifragen2], predict, tempdata, type="response")
            chances[multifragen2] = lapply(fitting2[multifragen2], predict, tempdata, type="probs")
            Entropietemp = chances
            Entropietemp[multifragen2] = lapply(chances[multifragen2], FUN.EntropieMC.IND)
            Entropietemp[-multifragen2] = lapply(chances[-multifragen2], FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        }

        Restentropietemp2[j] = sum(Entropietemp)
 #       modell[[i]] = fitting[[which(Entropietemp == max(Entropietemp))]]

if (length(fitting) > 1) {
        chances = fitting
multialt = multifragen
multifragen = multifragen[multifragen <= length(fitting)]
        if (length(multifragen) == 1) {
            chances = lapply(fitting, predict, komusmult[k,], type="response")
            Entropietemp = chances
            Entropietemp = lapply(chances, FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        } else {
            multifragen = multifragen[2:length(multifragen)]
            chances[-multifragen] = lapply(fitting[-multifragen], predict, komusmult[k,], type="response")
            chances[multifragen] = lapply(fitting[multifragen], predict, komusmult[k,], type="probs")
            Entropietemp = chances
            Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
            Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
            multifragen = c(0,multifragen)
        }
multifragen = multialt
        Restentropietemp[i-1] = sum(Entropietemp)
x11()
x = 1:10
y = x^2
plot(x ~ y, type='l')
}



} else {
Restentropietemp2[j] = 0 
}



        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = fitting
        if (length(multifragen) == 1) {
            chances = lapply(fitting, predict, komusmult[k,], type="response")
            Entropietemp = chances
            Entropietemp = lapply(chances, FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        } else {
            multifragen = multifragen[2:length(multifragen)]
            chances[-multifragen] = lapply(fitting[-multifragen], predict, komusmult[k,], type="response")
            chances[multifragen] = lapply(fitting[multifragen], predict, komusmult[k,], type="probs")
            Entropietemp = chances
            Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
            Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        }

        Restentropietemp[i-1] = sum(Entropietemp)
        fragen = c(fragen, which(names(komusmult[-fragen][which(Restentropietemp2 == min(Restentropietemp2))]) == names(komusmult)))
        modell[[i]] = fitting[[which(Entropietemp == max(Entropietemp))]]
    }

    if (length(komusmult) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        multifragen = 0
        multifragen = c(0,which(names(komusmult[-fragen]) %in% names(komusmult[multifragenalt])))
        for (j in 1:length(komusmult[-fragen])) {
            if (j %in% multifragen) {
                fitting[[j]] = polr(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult)
            } else {
                fitting[[j]] = glm(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult, family = "binomial"(link=logit))
            }
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)

        if (length(multifragen) == 1) {
            chances = lapply(fitting, predict, komusmult[k,], type="response")
            Entropietemp = chances
            Entropietemp = lapply(chances, FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
     
        } else {
            multifragen = multifragen[2:length(multifragen)]
            chances[-multifragen] = lapply(fitting[-multifragen], predict, komusmult[k,], type="response")
            chances[multifragen] = lapply(fitting[multifragen], predict, komusmult[k,], type="probs")
            Entropietemp = chances

    ### Funktion kann nicht benutzt werden, da sie auf nicht manipulierte multifragen zugreift
            Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
            Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        }

        Restentropietemp[items] = sum(Entropietemp)
    }
    multifragen = 0
    multifragen = c(multifragen,which(fragen %in% multifragenalt))

    if (length(multifragen) == 1) {
        chances = modell
        chances = lapply(modell, predict, komusmult[k,], type="response")
        Entropietemp = chances
        Entropietemp = lapply(chances, FUN.Entropie)
        Entropietemp = simplify2array(Entropietemp)
    } else {
        multifragen = multifragen[2:length(multifragen)]
        chances = modell
        chances[-multifragen] = lapply(modell[-multifragen], predict, komusmult[k,], type="response")
        chances[multifragen] = lapply(modell[multifragen], predict, komusmult[k,], type="probs")
        Entropietemp = chances

        Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
        Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
        Entropietemp = simplify2array(Entropietemp)
    }

    return(c(Entropietemp, Restentropietemp))    
})

Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]
 
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}
 
SumSD$indivbedsortpred = c(0,SumSDtemp)
EEE$indivbedsortpred = c(0,rowMeans(Entropieall))
RestEntropie$indivbedsortpred = c(0,rowMeans(Restentropietemp))
RestEntropieSD$indivbedsortpred = c(0,apply(Restentropietemp, 1, sd))

multifragen = multifragenalt
EEE
SumSD
RestEntropie
RestEntropieSD
'org_babel_R_eoe'
require(MASS)
library(multicore)
library(foreach)
library(doMC)
registerDoMC(1)

calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
komusmult = data.frame(read.table("data/komus.csv",header=TRUE, sep=','))
multifragen = array(which(sapply(komusmult, max) > 1))
multifragenalt = multifragen
komusmult[multifragen] = lapply(komusmult[multifragen],factor)

FUN.EntropieMC = function(x) {return(rowSums(-x*log(x+0.00000001, 2)))}
FUN.EntropieMC.IND = function(x) {return(sum(-x*log(x+0.00000001, 2)))}
FUN.Entropie = function(x) {return(-x*log(x+0.000001, 2)-(1-x)*log(1-x+0.00001, 2))}
FUN.Chances = function(x) {
    if (length(multifragen) > 0) {
        x[-multifragen] = lapply(x[-multifragen], predict, type="response")
        x[multifragen] = lapply(x[multifragen], predict, type="probs")
    } else {
        x = lapply(x, predict, type="response")
    }
    return(x)
}
FUN.Chances.IND = function(x,y) {
    x[-multifragen] = lapply(x[-multifragen], predict, data = komusmult[y,], type="response")
    x[multifragen] = lapply(x[multifragen], predict, data = komusmult[y,], type="probs")
    return(x)
}
FUN.Entropietemp = function(x) {
    if (length(multifragen) > 0) {
        x[multifragen] = lapply(x[multifragen], FUN.EntropieMC)
        x[-multifragen] =lapply(x[-multifragen], FUN.Entropie)
    } else {
        x =lapply(x, FUN.Entropie)
    }
    x = simplify2array(x)
    return(x)
}
FUN.Entropietemp.IND = function(x) {
    if (length(multifragen) > 0) {
        x[multifragen] = lapply(x[multifragen], FUN.EntropieMC.IND)
        x[-multifragen] =lapply(x[-multifragen], FUN.Entropie)
    } else {
        x =lapply(x, FUN.Entropie)
    }
    x = simplify2array(x)
    return(x)
}

Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()
############
items = length(komusmult)
#persons = length(komusmult[,1])
#items = 50
persons = 2
############

EEE = data.frame(matrix(ncol = 1, nrow = items+1))
SumSD = data.frame(matrix(ncol = 1, nrow = items+1))
RestEntropie = data.frame(matrix(ncol = 1, nrow = items+1))
RestEntropieSD = data.frame(matrix(ncol = 1, nrow = items+1))
names(EEE) = 'kill'
names(SumSD) = 'kill'
names(RestEntropie) = 'kill'
names(RestEntropieSD) = 'kill'
'org_babel_R_eoe'


fitting = NULL
Entropieall = NULL
chances = NULL
Restentropietemp = NULL
fragen = NULL
modell = NULL
Restentropietemp = NULL
multifragen = multifragenalt

############## sortierte Reihenfolge
for (i in 1:length(komusmult)) {
    if (i %in% multifragen) {
        fitting[[i]] = polr(reformulate('1', names(komusmult[i])), data = komusmult)
    } else {
        fitting[[i]] = glm(reformulate('1', names(komusmult[i])), data = komusmult, family = "binomial"(link=logit))
   }
}

chances = fitting
chances[-multifragen] = lapply(fitting[-multifragen], predict, komusmult[1,], type="response")
chances[multifragen] = lapply(fitting[multifragen], predict, komusmult[1,], type="probs")
Entropietemp = FUN.Entropietemp.IND(chances)
fragen = which(names(komusmult[which(Entropietemp == max(Entropietemp))]) == names(komusmult))
#########
modell[[1]] = fitting[[fragen]]
frageninit = fragen
fitting = NULL
Restentropie2 = NULL

Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = frageninit
    Restentropie = NULL
    Restentropietemp2 = NULL
    Restentropietemp = NULL
    for (i in 2:items) {
        chances = NULL
        Entropietemp = NULL
        fitting = NULL
        fitting2 = NULL
        fittingplus = NULL
        fittingminus = NULL
        Entropietemp2 = NULL
        multifragen = 0
        multifragen = c(multifragen,which(names(komusmult[-fragen]) %in% names(komusmult[multifragenalt])))
        for (j in 1:length(komusmult[-fragen])) {
            if (j %in% multifragen) {
                fitting[[j]] = polr(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult)
            } else {
                fitting[[j]] = glm(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult, family = "binomial"(link=logit))
            }
if (length(komusmult[-fragen]) > 1) {
            multifragen2 = c(0,which(names(komusmult[-fragen][-j]) %in% names(komusmult[multifragenalt])))
            for (n in 1:length(komusmult[-fragen][-j])) {
                if (n %in% multifragen2) {
                    fitting2[[n]] = polr(reformulate(names(c(komusmult[fragen], komusmult[-fragen][j])), names(komusmult[-fragen][-j][n])), data = komusmult)
                } else {
                    fitting2[[n]] = glm(reformulate(names(c(komusmult[fragen], komusmult[-fragen][j])), names(komusmult[-fragen][-j][n])), data = komusmult, family = "binomial"(link=logit))
                }
            }

        tempdata = komusmult[k,]
        tempdata[-fragen][j] = 0
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = fitting2
        if (length(multifragen2) == 1) {
            chances = lapply(fitting2, predict, tempdata, type="response")
            Entropietemp = chances
            Entropietemp = lapply(chances, FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        } else {
            multifragen2 = multifragen2[2:length(multifragen2)]
            chances[-multifragen2] = lapply(fitting2[-multifragen2], predict, tempdata, type="response")
            chances[multifragen2] = lapply(fitting2[multifragen2], predict, tempdata, type="probs")
            Entropietemp = chances
#print(chances)
### Funktion kann nicht benutzt werden, da sie auf nicht manipulierte multifragen zugreift
            Entropietemp[multifragen2] = lapply(chances[multifragen2], FUN.EntropieMC.IND)
            Entropietemp[-multifragen2] = lapply(chances[-multifragen2], FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        }

        Restentropietemp2[j] = sum(Entropietemp)
#        fragen = c(fragen, which(names(komusmult[-fragen][which(Entropietemp == max(Entropietemp))]) == names(komusmult)))
 #       modell[[i]] = fitting[[which(Entropietemp == max(Entropietemp))]]

#################################
if (length(fitting) > 1) {
        chances = fitting
multialt = multifragen
multifragen = multifragen[multifragen <= length(fitting)]
        if (length(multifragen) == 1) {
            chances = lapply(fitting, predict, komusmult[k,], type="response")
            Entropietemp = chances
            Entropietemp = lapply(chances, FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        } else {
            multifragen = multifragen[2:length(multifragen)]
            chances[-multifragen] = lapply(fitting[-multifragen], predict, komusmult[k,], type="response")
            chances[multifragen] = lapply(fitting[multifragen], predict, komusmult[k,], type="probs")
            Entropietemp = chances
#print(chances)
### Funktion kann nicht benutzt werden, da sie auf nicht manipulierte multifragen zugreift
            Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
            Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
            multifragen = c(0,multifragen)
        }
multifragen = multialt
        Restentropietemp[i-1] = sum(Entropietemp)

x = 1:length(Restentropietemp)
y = Restentropietemp
plot(x ~ y, type='l')
#lines(Restentropietemp) 
}

#################################


} else {
Restentropietemp2[j] = 0 
}



        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = fitting
        if (length(multifragen) == 1) {
            chances = lapply(fitting, predict, komusmult[k,], type="response")
            Entropietemp = chances
            Entropietemp = lapply(chances, FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        } else {
            multifragen = multifragen[2:length(multifragen)]
            chances[-multifragen] = lapply(fitting[-multifragen], predict, komusmult[k,], type="response")
            chances[multifragen] = lapply(fitting[multifragen], predict, komusmult[k,], type="probs")
            Entropietemp = chances
#print(chances)
### Funktion kann nicht benutzt werden, da sie auf nicht manipulierte multifragen zugreift
            Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
            Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        }

        Restentropietemp[i-1] = sum(Entropietemp)
        fragen = c(fragen, which(names(komusmult[-fragen][which(Restentropietemp2 == min(Restentropietemp2))]) == names(komusmult)))
        modell[[i]] = fitting[[which(Entropietemp == max(Entropietemp))]]
    }

    if (length(komusmult) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        multifragen = 0
        multifragen = c(0,which(names(komusmult[-fragen]) %in% names(komusmult[multifragenalt])))
        for (j in 1:length(komusmult[-fragen])) {
            if (j %in% multifragen) {
                fitting[[j]] = polr(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult)
            } else {
                fitting[[j]] = glm(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult, family = "binomial"(link=logit))
            }
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)

        if (length(multifragen) == 1) {
            chances = lapply(fitting, predict, komusmult[k,], type="response")
            Entropietemp = chances
            Entropietemp = lapply(chances, FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
     
        } else {
            multifragen = multifragen[2:length(multifragen)]
            chances[-multifragen] = lapply(fitting[-multifragen], predict, komusmult[k,], type="response")
            chances[multifragen] = lapply(fitting[multifragen], predict, komusmult[k,], type="probs")
            Entropietemp = chances

    ### Funktion kann nicht benutzt werden, da sie auf nicht manipulierte multifragen zugreift
            Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
            Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        }

        Restentropietemp[items] = sum(Entropietemp)
    }
    multifragen = 0
    multifragen = c(multifragen,which(fragen %in% multifragenalt))

    if (length(multifragen) == 1) {
        chances = modell
        chances = lapply(modell, predict, komusmult[k,], type="response")
        Entropietemp = chances
        Entropietemp = lapply(chances, FUN.Entropie)
        Entropietemp = simplify2array(Entropietemp)
    } else {
        multifragen = multifragen[2:length(multifragen)]
        chances = modell
        chances[-multifragen] = lapply(modell[-multifragen], predict, komusmult[k,], type="response")
        chances[multifragen] = lapply(modell[multifragen], predict, komusmult[k,], type="probs")
        Entropietemp = chances

### Funktion kann nicht benutzt werden, da sie auf nicht manipulierte multifragen zugreift
        Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
        Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
        Entropietemp = simplify2array(Entropietemp)
    }

    return(c(Entropietemp, Restentropietemp))    
})

Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]
 
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}
 
SumSD$indivbedsortpred = c(0,SumSDtemp)
EEE$indivbedsortpred = c(0,rowMeans(Entropieall))
RestEntropie$indivbedsortpred = c(0,rowMeans(Restentropietemp))
RestEntropieSD$indivbedsortpred = c(0,apply(Restentropietemp, 1, sd))

multifragen = multifragenalt
EEE
SumSD
RestEntropie
RestEntropieSD
'org_babel_R_eoe'


fitting = NULL
Entropieall = NULL
chances = NULL
Restentropietemp = NULL
fragen = NULL
modell = NULL
Restentropietemp = NULL
multifragen = multifragenalt

############## sortierte Reihenfolge
for (i in 1:length(komusmult)) {
    if (i %in% multifragen) {
        fitting[[i]] = polr(reformulate('1', names(komusmult[i])), data = komusmult)
    } else {
        fitting[[i]] = glm(reformulate('1', names(komusmult[i])), data = komusmult, family = "binomial"(link=logit))
   }
}

chances = fitting
chances[-multifragen] = lapply(fitting[-multifragen], predict, komusmult[1,], type="response")
chances[multifragen] = lapply(fitting[multifragen], predict, komusmult[1,], type="probs")
Entropietemp = FUN.Entropietemp.IND(chances)
fragen = which(names(komusmult[which(Entropietemp == max(Entropietemp))]) == names(komusmult))
#########
modell[[1]] = fitting[[fragen]]
frageninit = fragen
fitting = NULL
Restentropie2 = NULL

Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = frageninit
    Restentropie = NULL
    Restentropietemp2 = NULL
    Restentropietemp = NULL
    for (i in 2:items) {
        chances = NULL
        Entropietemp = NULL
        fitting = NULL
        fitting2 = NULL
        fittingplus = NULL
        fittingminus = NULL
        Entropietemp2 = NULL
        multifragen = 0
        multifragen = c(multifragen,which(names(komusmult[-fragen]) %in% names(komusmult[multifragenalt])))
        for (j in 1:length(komusmult[-fragen])) {
            if (j %in% multifragen) {
                fitting[[j]] = polr(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult)
            } else {
                fitting[[j]] = glm(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult, family = "binomial"(link=logit))
            }
if (length(komusmult[-fragen]) > 1) {
            multifragen2 = c(0,which(names(komusmult[-fragen][-j]) %in% names(komusmult[multifragenalt])))
            for (n in 1:length(komusmult[-fragen][-j])) {
                if (n %in% multifragen2) {
                    fitting2[[n]] = polr(reformulate(names(c(komusmult[fragen], komusmult[-fragen][j])), names(komusmult[-fragen][-j][n])), data = komusmult)
                } else {
                    fitting2[[n]] = glm(reformulate(names(c(komusmult[fragen], komusmult[-fragen][j])), names(komusmult[-fragen][-j][n])), data = komusmult, family = "binomial"(link=logit))
                }
            }

        tempdata = komusmult[k,]
        tempdata[-fragen][j] = 0
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = fitting2
        if (length(multifragen2) == 1) {
            chances = lapply(fitting2, predict, tempdata, type="response")
            Entropietemp = chances
            Entropietemp = lapply(chances, FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        } else {
            multifragen2 = multifragen2[2:length(multifragen2)]
            chances[-multifragen2] = lapply(fitting2[-multifragen2], predict, tempdata, type="response")
            chances[multifragen2] = lapply(fitting2[multifragen2], predict, tempdata, type="probs")
            Entropietemp = chances
#print(chances)
### Funktion kann nicht benutzt werden, da sie auf nicht manipulierte multifragen zugreift
            Entropietemp[multifragen2] = lapply(chances[multifragen2], FUN.EntropieMC.IND)
            Entropietemp[-multifragen2] = lapply(chances[-multifragen2], FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        }

        Restentropietemp2[j] = sum(Entropietemp)
#        fragen = c(fragen, which(names(komusmult[-fragen][which(Entropietemp == max(Entropietemp))]) == names(komusmult)))
 #       modell[[i]] = fitting[[which(Entropietemp == max(Entropietemp))]]

#################################
if (length(fitting) > 1) {
        chances = fitting
multialt = multifragen
multifragen = multifragen[multifragen <= length(fitting)]
        if (length(multifragen) == 1) {
            chances = lapply(fitting, predict, komusmult[k,], type="response")
            Entropietemp = chances
            Entropietemp = lapply(chances, FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        } else {
            multifragen = multifragen[2:length(multifragen)]
            chances[-multifragen] = lapply(fitting[-multifragen], predict, komusmult[k,], type="response")
            chances[multifragen] = lapply(fitting[multifragen], predict, komusmult[k,], type="probs")
            Entropietemp = chances
#print(chances)
### Funktion kann nicht benutzt werden, da sie auf nicht manipulierte multifragen zugreift
            Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
            Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
            multifragen = c(0,multifragen)
        }
multifragen = multialt
        Restentropietemp[j-1] = sum(Entropietemp)

x = 1:length(Restentropietemp)
y = Restentropietemp
plot(x ~ y, type='l')
#lines(Restentropietemp) 
}

#################################


} else {
Restentropietemp2[j] = 0 
}



        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = fitting
        if (length(multifragen) == 1) {
            chances = lapply(fitting, predict, komusmult[k,], type="response")
            Entropietemp = chances
            Entropietemp = lapply(chances, FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        } else {
            multifragen = multifragen[2:length(multifragen)]
            chances[-multifragen] = lapply(fitting[-multifragen], predict, komusmult[k,], type="response")
            chances[multifragen] = lapply(fitting[multifragen], predict, komusmult[k,], type="probs")
            Entropietemp = chances
#print(chances)
### Funktion kann nicht benutzt werden, da sie auf nicht manipulierte multifragen zugreift
            Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
            Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        }

        Restentropietemp[i-1] = sum(Entropietemp)
        fragen = c(fragen, which(names(komusmult[-fragen][which(Restentropietemp2 == min(Restentropietemp2))]) == names(komusmult)))
        modell[[i]] = fitting[[which(Entropietemp == max(Entropietemp))]]
    }

    if (length(komusmult) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        multifragen = 0
        multifragen = c(0,which(names(komusmult[-fragen]) %in% names(komusmult[multifragenalt])))
        for (j in 1:length(komusmult[-fragen])) {
            if (j %in% multifragen) {
                fitting[[j]] = polr(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult)
            } else {
                fitting[[j]] = glm(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult, family = "binomial"(link=logit))
            }
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)

        if (length(multifragen) == 1) {
            chances = lapply(fitting, predict, komusmult[k,], type="response")
            Entropietemp = chances
            Entropietemp = lapply(chances, FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
     
        } else {
            multifragen = multifragen[2:length(multifragen)]
            chances[-multifragen] = lapply(fitting[-multifragen], predict, komusmult[k,], type="response")
            chances[multifragen] = lapply(fitting[multifragen], predict, komusmult[k,], type="probs")
            Entropietemp = chances

    ### Funktion kann nicht benutzt werden, da sie auf nicht manipulierte multifragen zugreift
            Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
            Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        }

        Restentropietemp[items] = sum(Entropietemp)
    }
    multifragen = 0
    multifragen = c(multifragen,which(fragen %in% multifragenalt))

    if (length(multifragen) == 1) {
        chances = modell
        chances = lapply(modell, predict, komusmult[k,], type="response")
        Entropietemp = chances
        Entropietemp = lapply(chances, FUN.Entropie)
        Entropietemp = simplify2array(Entropietemp)
    } else {
        multifragen = multifragen[2:length(multifragen)]
        chances = modell
        chances[-multifragen] = lapply(modell[-multifragen], predict, komusmult[k,], type="response")
        chances[multifragen] = lapply(modell[multifragen], predict, komusmult[k,], type="probs")
        Entropietemp = chances

### Funktion kann nicht benutzt werden, da sie auf nicht manipulierte multifragen zugreift
        Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
        Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
        Entropietemp = simplify2array(Entropietemp)
    }

    return(c(Entropietemp, Restentropietemp))    
})

Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]
 
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}
 
SumSD$indivbedsortpred = c(0,SumSDtemp)
EEE$indivbedsortpred = c(0,rowMeans(Entropieall))
RestEntropie$indivbedsortpred = c(0,rowMeans(Restentropietemp))
RestEntropieSD$indivbedsortpred = c(0,apply(Restentropietemp, 1, sd))

multifragen = multifragenalt
EEE
SumSD
RestEntropie
RestEntropieSD
'org_babel_R_eoe'


fitting = NULL
Entropieall = NULL
chances = NULL
Restentropietemp = NULL
fragen = NULL
modell = NULL
Restentropietemp = NULL
multifragen = multifragenalt

############## sortierte Reihenfolge
for (i in 1:length(komusmult)) {
    if (i %in% multifragen) {
        fitting[[i]] = polr(reformulate('1', names(komusmult[i])), data = komusmult)
    } else {
        fitting[[i]] = glm(reformulate('1', names(komusmult[i])), data = komusmult, family = "binomial"(link=logit))
   }
}

chances = fitting
chances[-multifragen] = lapply(fitting[-multifragen], predict, komusmult[1,], type="response")
chances[multifragen] = lapply(fitting[multifragen], predict, komusmult[1,], type="probs")
Entropietemp = FUN.Entropietemp.IND(chances)
fragen = which(names(komusmult[which(Entropietemp == max(Entropietemp))]) == names(komusmult))
#########
modell[[1]] = fitting[[fragen]]
frageninit = fragen
fitting = NULL
Restentropie2 = NULL

Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = frageninit
    Restentropie = NULL
    Restentropietemp2 = NULL
    Restentropietemp = NULL
    for (i in 2:items) {
        chances = NULL
        Entropietemp = NULL
        fitting = NULL
        fitting2 = NULL
        fittingplus = NULL
        fittingminus = NULL
        Entropietemp2 = NULL
        multifragen = 0
        multifragen = c(multifragen,which(names(komusmult[-fragen]) %in% names(komusmult[multifragenalt])))
        for (j in 1:length(komusmult[-fragen])) {
            if (j %in% multifragen) {
                fitting[[j]] = polr(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult)
            } else {
                fitting[[j]] = glm(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult, family = "binomial"(link=logit))
            }
if (length(komusmult[-fragen]) > 1) {
            multifragen2 = c(0,which(names(komusmult[-fragen][-j]) %in% names(komusmult[multifragenalt])))
            for (n in 1:length(komusmult[-fragen][-j])) {
                if (n %in% multifragen2) {
                    fitting2[[n]] = polr(reformulate(names(c(komusmult[fragen], komusmult[-fragen][j])), names(komusmult[-fragen][-j][n])), data = komusmult)
                } else {
                    fitting2[[n]] = glm(reformulate(names(c(komusmult[fragen], komusmult[-fragen][j])), names(komusmult[-fragen][-j][n])), data = komusmult, family = "binomial"(link=logit))
                }
            }

        tempdata = komusmult[k,]
#        tempdata[-fragen][j] = 0
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = fitting2
        if (length(multifragen2) == 1) {
            chances = lapply(fitting2, predict, tempdata, type="response")
            Entropietemp = chances
            Entropietemp = lapply(chances, FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        } else {
            multifragen2 = multifragen2[2:length(multifragen2)]
            chances[-multifragen2] = lapply(fitting2[-multifragen2], predict, tempdata, type="response")
            chances[multifragen2] = lapply(fitting2[multifragen2], predict, tempdata, type="probs")
            Entropietemp = chances
#print(chances)
### Funktion kann nicht benutzt werden, da sie auf nicht manipulierte multifragen zugreift
            Entropietemp[multifragen2] = lapply(chances[multifragen2], FUN.EntropieMC.IND)
            Entropietemp[-multifragen2] = lapply(chances[-multifragen2], FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        }

        Restentropietemp2[j] = sum(Entropietemp)
#        fragen = c(fragen, which(names(komusmult[-fragen][which(Entropietemp == max(Entropietemp))]) == names(komusmult)))
 #       modell[[i]] = fitting[[which(Entropietemp == max(Entropietemp))]]

#################################
if (length(fitting) > 1) {
        chances = fitting
multialt = multifragen
multifragen = multifragen[multifragen <= length(fitting)]
        if (length(multifragen) == 1) {
            chances = lapply(fitting, predict, komusmult[k,], type="response")
            Entropietemp = chances
            Entropietemp = lapply(chances, FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        } else {
            multifragen = multifragen[2:length(multifragen)]
            chances[-multifragen] = lapply(fitting[-multifragen], predict, komusmult[k,], type="response")
            chances[multifragen] = lapply(fitting[multifragen], predict, komusmult[k,], type="probs")
            Entropietemp = chances
#print(chances)
### Funktion kann nicht benutzt werden, da sie auf nicht manipulierte multifragen zugreift
            Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
            Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
            multifragen = c(0,multifragen)
        }
multifragen = multialt
        Restentropietemp[k-1] = sum(Entropietemp)

x = 1:length(Restentropietemp2)
y = Restentropietemp2
plot(x ~ y, type='l')
#lines(Restentropietemp) 
}

#################################


} else {
Restentropietemp2[j] = 0 
}



        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = fitting
        if (length(multifragen) == 1) {
            chances = lapply(fitting, predict, komusmult[k,], type="response")
            Entropietemp = chances
            Entropietemp = lapply(chances, FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        } else {
            multifragen = multifragen[2:length(multifragen)]
            chances[-multifragen] = lapply(fitting[-multifragen], predict, komusmult[k,], type="response")
            chances[multifragen] = lapply(fitting[multifragen], predict, komusmult[k,], type="probs")
            Entropietemp = chances
#print(chances)
### Funktion kann nicht benutzt werden, da sie auf nicht manipulierte multifragen zugreift
            Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
            Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        }

        Restentropietemp[i-1] = sum(Entropietemp)
        fragen = c(fragen, which(names(komusmult[-fragen][which(Restentropietemp2 == min(Restentropietemp2))]) == names(komusmult)))
        modell[[i]] = fitting[[which(Entropietemp == max(Entropietemp))]]
    }

    if (length(komusmult) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        multifragen = 0
        multifragen = c(0,which(names(komusmult[-fragen]) %in% names(komusmult[multifragenalt])))
        for (j in 1:length(komusmult[-fragen])) {
            if (j %in% multifragen) {
                fitting[[j]] = polr(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult)
            } else {
                fitting[[j]] = glm(reformulate(names(komusmult[fragen]), names(komusmult[-fragen][j])), data = komusmult, family = "binomial"(link=logit))
            }
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)

        if (length(multifragen) == 1) {
            chances = lapply(fitting, predict, komusmult[k,], type="response")
            Entropietemp = chances
            Entropietemp = lapply(chances, FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
     
        } else {
            multifragen = multifragen[2:length(multifragen)]
            chances[-multifragen] = lapply(fitting[-multifragen], predict, komusmult[k,], type="response")
            chances[multifragen] = lapply(fitting[multifragen], predict, komusmult[k,], type="probs")
            Entropietemp = chances

    ### Funktion kann nicht benutzt werden, da sie auf nicht manipulierte multifragen zugreift
            Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
            Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
            Entropietemp = simplify2array(Entropietemp)
        }

        Restentropietemp[items] = sum(Entropietemp)
    }
    multifragen = 0
    multifragen = c(multifragen,which(fragen %in% multifragenalt))

    if (length(multifragen) == 1) {
        chances = modell
        chances = lapply(modell, predict, komusmult[k,], type="response")
        Entropietemp = chances
        Entropietemp = lapply(chances, FUN.Entropie)
        Entropietemp = simplify2array(Entropietemp)
    } else {
        multifragen = multifragen[2:length(multifragen)]
        chances = modell
        chances[-multifragen] = lapply(modell[-multifragen], predict, komusmult[k,], type="response")
        chances[multifragen] = lapply(modell[multifragen], predict, komusmult[k,], type="probs")
        Entropietemp = chances

### Funktion kann nicht benutzt werden, da sie auf nicht manipulierte multifragen zugreift
        Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC.IND)
        Entropietemp[-multifragen] = lapply(chances[-multifragen], FUN.Entropie)
        Entropietemp = simplify2array(Entropietemp)
    }

    return(c(Entropietemp, Restentropietemp))    
})

Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]
 
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}
 
SumSD$indivbedsortpred = c(0,SumSDtemp)
EEE$indivbedsortpred = c(0,rowMeans(Entropieall))
RestEntropie$indivbedsortpred = c(0,rowMeans(Restentropietemp))
RestEntropieSD$indivbedsortpred = c(0,apply(Restentropietemp, 1, sd))

multifragen = multifragenalt
EEE
SumSD
RestEntropie
RestEntropieSD
'org_babel_R_eoe'
