'org_babel_R_eoe'
calculationtime <- proc.time()



datatest <- data.frame(matrix(ncol = 1, nrow = 3))

datatest$muu =  c(1,6,88)
datatest

if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}
'org_babel_R_eoe'
calculationtime <- proc.time()



datatest <- data.frame(matrix(ncol = 1, nrow = 3))

datatest$muu =  c(1,6,88)
datatest$muu = c(1,99,55)
datatest

if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}
'org_babel_R_eoe'
library(multicore)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

items = 2
persons = 1

Entrodf =  data.frame(matrix(ncol = 1, nrow = items))
'org_babel_R_eoe'
modell[[1]] = glm(V1 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(colMeans(Entropietemp))
Entrodf$bedunsor = colMeans(Entropietemp)
Entropie = cbind(Entropie,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
Entropie = cbind(Entropie,sort(Entropie[,2], decreasing = TRUE))
Entropie = cbind(Entropie,sort(Entropie[,1], decreasing = TRUE))
Entrodf
'org_babel_R_eoe'
modell[[1]] = glm(V1 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(colMeans(Entropietemp))
Entrodf$bedunsor = colMeans(Entropietemp)
Entropie = cbind(Entropie,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
Entropie = cbind(Entropie,sort(Entropie[,2], decreasing = TRUE))
Entropie = cbind(Entropie,sort(Entropie[,1], decreasing = TRUE))
Entrodf
'org_babel_R_eoe'
modell[[1]] = glm(V1 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(colMeans(Entropietemp))
Entrodf$bedunsor = colMeans(Entropietemp)
Entropie = cbind(Entropie,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
Entrodf$unbedunsor = Entropie,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2)
Entropie = cbind(Entropie,sort(Entropie[,2], decreasing = TRUE))
Entrodf$unbedsor = Entropie,sort(Entropie[,2], decreasing = TRUE)
Entropie = cbind(Entropie,sort(Entropie[,1], decreasing = TRUE))
Entrodf$bedsor = Entropie,sort(Entropie[,1], decreasing = TRUE)
Entrodef
'org_babel_R_eoe'
modell[[1]] = glm(V1 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(colMeans(Entropietemp))
Entrodf$bedunsor = colMeans(Entropietemp)
Entropie = cbind(Entropie,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
Entrodf$unbedunsor = Entropie,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2)
Entropie = cbind(Entropie,sort(Entropie[,2], decreasing = TRUE))
Entrodf$unbedsor = Entropie,sort(Entropie[,2], decreasing = TRUE)
Entropie = cbind(Entropie,sort(Entropie[,1], decreasing = TRUE))
Entrodf$bedsor = Entropie,sort(Entropie[,1], decreasing = TRUE)
Entrodf
'org_babel_R_eoe'
modell[[1]] = glm(V1 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(colMeans(Entropietemp))
Entrodf$bedunsor = colMeans(Entropietemp)
Entropie = cbind(Entropie,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
Entrodf$unbedunsor = -colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2)
Entropie = cbind(Entropie,sort(Entropie[,2], decreasing = TRUE))
Entrodf$unbedsor = sort(Entropie[,2], decreasing = TRUE)
Entropie = cbind(Entropie,sort(Entropie[,1], decreasing = TRUE))
Entrodf$bedsor = sort(Entropie[,1], decreasing = TRUE)
Entrodf
'org_babel_R_eoe'
modell[[1]] = glm(V1 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)
Entropie = cbind(colMeans(Entropietemp))
Entrodf$bedunsor = colMeans(Entropietemp)
Entropie = cbind(Entropie,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
Entrodf$unbedunsor = -colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2)
Entropie = cbind(Entropie,sort(Entropie[,2], decreasing = TRUE))
Entrodf$unbedsor = sort(Entropie[,2], decreasing = TRUE)
Entropie = cbind(Entropie,sort(Entropie[,1], decreasing = TRUE))
Entrodf$bedsor = sort(Entropie[,1], decreasing = TRUE)
Entrodf
Entropie
'org_babel_R_eoe'
library(multicore)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

items = 2
persons = 1

Entrodf =  data.frame(matrix(ncol = 1, nrow = items))
Entrodf[1] = 4
Entrodf
'org_babel_R_eoe'
library(multicore)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

items = 2
persons = 1

Entrodf =  data.frame(matrix(ncol = 1, nrow = items))
name(Entrodf[1]) = 'mu'
Entrodf
'org_babel_R_eoe'
library(multicore)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

items = 2
persons = 1

Entrodf =  data.frame(matrix(ncol = 1, nrow = items))
names(Entrodf[1]) = 'mu'
Entrodf
'org_babel_R_eoe'
library(multicore)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

items = 2
persons = 1

Entrodf =  data.frame(matrix(ncol = 1, nrow = items))
colnames(Entrodf[1]) = 'mu'
Entrodf
'org_babel_R_eoe'
library(multicore)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

items = 2
persons = 1

Entrodf =  data.frame(matrix(ncol = 1, nrow = items))
colnames(Entrodf) = 'mu'
Entrodf
'org_babel_R_eoe'
library(multicore)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

items = 2
persons = 1

Entrodf =  data.frame(matrix(ncol = 1, nrow = items))
names(Entrodf) = 'mu'
Entrodf
'org_babel_R_eoe'
library(multicore)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

items = 2
persons = 1

Entrodf =  data.frame(matrix(ncol = 1, nrow = items))
names(Entrodf) = 'kill'
Entrodf
'org_babel_R_eoe'
library(multicore)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

items = 2
persons = 1

Entrodf =  data.frame(matrix(ncol = 1, nrow = items))
names(Entrodf) = 'kill'
Entrodf
Entrodf$kill
'org_babel_R_eoe'
library(multicore)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

items = 2
persons = 1

Entrodf =  data.frame(matrix(ncol = 1, nrow = items))
names(Entrodf) = 'kill'
Entrodf
Entrodf$eatrtkill
'org_babel_R_eoe'
library(multicore)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

items = 2
persons = 1

Entrodf =  data.frame(matrix(ncol = 1, nrow = items))
names(Entrodf) = 'kill'
Entrodf
Entrodf$kill == NULL
'org_babel_R_eoe'
library(multicore)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

items = 2
persons = 1

Entrodf =  data.frame(matrix(ncol = 1, nrow = items))
names(Entrodf) = 'kill'
Entrodf
Entrodf$iekill == NULL
'org_babel_R_eoe'
library(multicore)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

items = 2
persons = 1

Entrodf =  data.frame(matrix(ncol = 1, nrow = items))
names(Entrodf) = 'kill'
Entrodf
Entrodf$kill == NA
'org_babel_R_eoe'
library(multicore)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

items = 2
persons = 1

Entrodf =  data.frame(matrix(ncol = 1, nrow = items))
names(Entrodf) = 'kill'
Entrodf$kill == 4
'org_babel_R_eoe'
library(multicore)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()

items = 2
persons = 1

Entrodf =  data.frame(matrix(ncol = 1, nrow = items))
names(Entrodf) = 'kill'
Entrodf$kill ==
'org_babel_R_eoe'
library(multicore)
library(foreach)
library(doMC)
registerDoMC(8)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()
############
#items = length(komus)
#persons = length(komus[,1])
items = 10
persons = 3
############

EEE = data.frame(matrix(ncol = 1, nrow = items))
SumSD = data.frame(matrix(ncol = 1, nrow = items))
names(EEE) = 'kill'
names(SumSD) = 'kill'
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
    
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    
    return(Entropietemp)
})

Entropieall
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsorttrenn = SumSDtemp 
EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
    
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    
    return(Entropietemp)
})
 -colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2)
Entropieall
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsorttrenn = SumSDtemp 
EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
    
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    
    return(Entropietemp)
})
sum(-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
Entropieall
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsorttrenn = SumSDtemp 
EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropie = 10
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[i] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropie))
})

Entropieall
#SumSDtemp = sd(Entropieall[1,])
#for (i in 2:length(Entropieall[,1])) {
#SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
#}

#SumSD$indivbedsorttrenn = SumSDtemp 
#EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropie = 10
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropie))
})

Entropieall[1:items,]
#SumSDtemp = sd(Entropieall[1,])
#for (i in 2:length(Entropieall[,1])) {
#SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
#}

#SumSD$indivbedsorttrenn = SumSDtemp 
#EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropie = 10
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropie))
})

Entropieall[1:items+1,]
#SumSDtemp = sd(Entropieall[1,])
#for (i in 2:length(Entropieall[,1])) {
#SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
#}

#SumSD$indivbedsorttrenn = SumSDtemp 
#EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropie = 10
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropie))
})

Entropieall[1:items+1,]
Restentropie = Entropieall[items:items*2]
Restentropie
#SumSDtemp = sd(Entropieall[1,])
#for (i in 2:length(Entropieall[,1])) {
#SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
#}

#SumSD$indivbedsorttrenn = SumSDtemp 
#EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropie = 10
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropie))
})

Entropieall[1:items+1,]
Restentropie = Entropieall[items:items*2,]
Restentropie
#SumSDtemp = sd(Entropieall[1,])
#for (i in 2:length(Entropieall[,1])) {
#SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
#}

#SumSD$indivbedsorttrenn = SumSDtemp 
#EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropie = 10
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropie))
})

Entropieall[1:items+1,]
Restentropie = Entropieall[items:items*2-1,]
Restentropie
#SumSDtemp = sd(Entropieall[1,])
#for (i in 2:length(Entropieall[,1])) {
#SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
#}

#SumSD$indivbedsorttrenn = SumSDtemp 
#EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropie = 10
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropie))
})

Entropieall[1:items+1,]
Restentropie = Entropieall[items:items+items,]
Restentropie
#SumSDtemp = sd(Entropieall[1,])
#for (i in 2:length(Entropieall[,1])) {
#SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
#}

#SumSD$indivbedsorttrenn = SumSDtemp 
#EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropie = 10
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropie))
})

Entropieall[items:items+1,]
#Restentropie = Entropieall[items:items+items,]
Restentropie
#SumSDtemp = sd(Entropieall[1,])
#for (i in 2:length(Entropieall[,1])) {
#SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
#}

#SumSD$indivbedsorttrenn = SumSDtemp 
#EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropie = 10
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropie))
})

Entropieall[items:items+5,]
#Restentropie = Entropieall[items:items+items,]
Restentropie
#SumSDtemp = sd(Entropieall[1,])
#for (i in 2:length(Entropieall[,1])) {
#SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
#}

#SumSD$indivbedsorttrenn = SumSDtemp 
#EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropie = 10
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropie))
})

Entropieall[items:(items+5),]
#Restentropie = Entropieall[items:items+items,]
Restentropie
#SumSDtemp = sd(Entropieall[1,])
#for (i in 2:length(Entropieall[,1])) {
#SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
#}

#SumSD$indivbedsorttrenn = SumSDtemp 
#EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropie = 10
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropie))
})

Entropieall[items:(items+items),]
#Restentropie = Entropieall[items:items+items,]
Restentropie
#SumSDtemp = sd(Entropieall[1,])
#for (i in 2:length(Entropieall[,1])) {
#SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
#}

#SumSD$indivbedsorttrenn = SumSDtemp 
#EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropie = 10
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropie))
})

#Entropieall[items:(items+items),]
Restentropie = Entropieall[items:(items*2-1),]
Restentropie
#SumSDtemp = sd(Entropieall[1,])
#for (i in 2:length(Entropieall[,1])) {
#SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
#}

#SumSD$indivbedsorttrenn = SumSDtemp 
#EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropie = 10
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropie))
})

#Entropieall[items:(items+items),]
Entropieall[items,]
Restentropie = Entropieall[items:(items*2-1),]
Restentropie
#SumSDtemp = sd(Entropieall[1,])
#for (i in 2:length(Entropieall[,1])) {
#SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
#}

#SumSD$indivbedsorttrenn = SumSDtemp 
#EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropie = 10
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropie))
})

#Entropieall[items:(items+items),]
Entropieall[items,]
Restentropie = Entropieall[(items+1):(items*2-1),]
Restentropie
#SumSDtemp = sd(Entropieall[1,])
#for (i in 2:length(Entropieall[,1])) {
#SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
#}

#SumSD$indivbedsorttrenn = SumSDtemp 
#EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropie = 10
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropie))
})

Entropieall
Restentropie = Entropieall[(items+1):(items*2-1),]
Entropieall = Entropieall[1:items,]
Restentropie
Entropieall
#SumSDtemp = sd(Entropieall[1,])
#for (i in 2:length(Entropieall[,1])) {
#SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
#}

#SumSD$indivbedsorttrenn = SumSDtemp 
#EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropie = 10
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c('')
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropie))
})


Restentropie = Entropieall[(items+1):(items*2-1),]
Entropieall = Entropieall[1:items,]

#SumSDtemp = sd(Entropieall[1,])
#for (i in 2:length(Entropieall[,1])) {
#SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
#}

#SumSD$indivbedsorttrenn = SumSDtemp 
#EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropie = 10
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(0)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropie))
})


Restentropie = Entropieall[(items+1):(items*2-1),]
Entropieall = Entropieall[1:items,]

#SumSDtemp = sd(Entropieall[1,])
#for (i in 2:length(Entropieall[,1])) {
#SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
#}

#SumSD$indivbedsorttrenn = SumSDtemp 
#EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropie = 10
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropie))
})


Restentropie = Entropieall[(items+1):(items*2-1),]
Entropieall = Entropieall[1:items,]

#SumSDtemp = sd(Entropieall[1,])
#for (i in 2:length(Entropieall[,1])) {
#SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
#}

#SumSD$indivbedsorttrenn = SumSDtemp 
#EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropie = 10
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    if (length(fragen) == items) {
        Restentropie[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }



    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropie))
})


Restentropie = Entropieall[(items+1):(items*2),]
Entropieall = Entropieall[1:items,]

#SumSDtemp = sd(Entropieall[1,])
#for (i in 2:length(Entropieall[,1])) {
#SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
#}

#SumSD$indivbedsorttrenn = SumSDtemp 
#EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropie = 10
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    if (length(fragen) == items) {
        Restentropie[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }



    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropie))
})

Entropieall
Restentropie = Entropieall[(items+1):(items*2),]
Entropieall = Entropieall[1:items,]
Restentropie
#SumSDtemp = sd(Entropieall[1,])
#for (i in 2:length(Entropieall[,1])) {
#SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
#}

#SumSD$indivbedsorttrenn = SumSDtemp 
#EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropie = 10
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    if (length(fragen) == items) {
        Restentropie[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }



    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropie))
})
length(komus)
Entropieall
Restentropie = Entropieall[(items+1):(items*2),]
Entropieall = Entropieall[1:items,]
Restentropie
#SumSDtemp = sd(Entropieall[1,])
#for (i in 2:length(Entropieall[,1])) {
#SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
#}

#SumSD$indivbedsorttrenn = SumSDtemp 
#EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropie = 10
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    if (length(komus) == items) {
        Restentropie[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropie[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }



    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropie))
})

Entropieall
Restentropie = Entropieall[(items+1):(items*2),]
Entropieall = Entropieall[1:items,]
Restentropie
#SumSDtemp = sd(Entropieall[1,])
#for (i in 2:length(Entropieall[,1])) {
#SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
#}

#SumSD$indivbedsorttrenn = SumSDtemp 
#EEE$indivbedsorttrenn = rowMeans(Entropieall)
'org_babel_R_eoe'
library(multicore)
library(foreach)
library(doMC)
registerDoMC(8)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()
############
#items = length(komus)
#persons = length(komus[,1])
items = 10
persons = 3
############

EEE = data.frame(matrix(ncol = 1, nrow = items))
SumSD = data.frame(matrix(ncol = 1, nrow = items))
RestEntropie = data.frame(matrix(ncol = 1, nrow = items))
RestEntropieSD = data.frame(matrix(ncol = 1, nrow = items))
names(EEE) = 'kill'
names(SumSD) = 'kill'

names(EEE)
names(SumSD)
'org_babel_R_eoe'
library(multicore)
library(foreach)
library(doMC)
registerDoMC(8)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()
############
#items = length(komus)
#persons = length(komus[,1])
items = 10
persons = 3
############

EEE = data.frame(matrix(ncol = 1, nrow = items))
SumSD = data.frame(matrix(ncol = 1, nrow = items))
RestEntropie = data.frame(matrix(ncol = 1, nrow = items))
RestEntropieSD = data.frame(matrix(ncol = 1, nrow = items))
names(EEE) = 'kill'
#names(SumSD) = 'kill'

names(EEE)
names(SumSD)
'org_babel_R_eoe'
library(multicore)
library(foreach)
library(doMC)
registerDoMC(8)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()
############
#items = length(komus)
#persons = length(komus[,1])
items = 10
persons = 3
############

EEE = data.frame(matrix(ncol = 1, nrow = items))
SumSD = data.frame(matrix(ncol = 1, nrow = items))
RestEntropie = data.frame(matrix(ncol = 1, nrow = items))
RestEntropieSD = data.frame(matrix(ncol = 1, nrow = items))
names(EEE, SumSD) = 'kill'
#names(SumSD) = 'kill'

names(EEE)
names(SumSD)
'org_babel_R_eoe'
library(multicore)
library(foreach)
library(doMC)
registerDoMC(8)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()
############
#items = length(komus)
#persons = length(komus[,1])
items = 10
persons = 3
############

EEE = data.frame(matrix(ncol = 1, nrow = items))
SumSD = data.frame(matrix(ncol = 1, nrow = items))
RestEntropie = data.frame(matrix(ncol = 1, nrow = items))
RestEntropieSD = data.frame(matrix(ncol = 1, nrow = items))
names(EEE), names(SumSD) = 'kill'
#names(SumSD) = 'kill'

names(EEE)
names(SumSD)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropietemp = NULL
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    if (length(komus) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }



    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropietemp))
})


Restentropietemp = Entropieall[(items+1):(items*2),]
Entropieall = Entropieall[1:items,]
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsorttrenn = SumSDtemp 
EEE$indivbedsorttrenn = rowMeans(Entropieall)
Restentropie$indivbedsorttrenn = rowMeans(Restentropietemp)
RestentropieSD$indivbedsorttrenn = sd(Restentropietemp)
Restentropie
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropietemp = NULL
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    if (length(komus) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }



    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropietemp))
})


Restentropietemp = data.frame(Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsorttrenn = SumSDtemp 
EEE$indivbedsorttrenn = rowMeans(Entropieall)
Restentropie$indivbedsorttrenn = rowMeans(Restentropietemp)
RestentropieSD$indivbedsorttrenn = sd(Restentropietemp)
Restentropie
'org_babel_R_eoe'
library(multicore)
library(foreach)
library(doMC)
registerDoMC(8)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()
############
#items = length(komus)
#persons = length(komus[,1])
items = 10
persons = 3
############

EEE = data.frame(matrix(ncol = 1, nrow = items))
SumSD = data.frame(matrix(ncol = 1, nrow = items))
RestEntropie = data.frame(matrix(ncol = 1, nrow = items))
RestEntropieSD = data.frame(matrix(ncol = 1, nrow = items))
names(EEE) = 'kill'
names(SumSD) = 'kill'
names(RestEntropie) = 'kill'
names(RestEntropieSD) = 'kill'
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropietemp = NULL
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    if (length(komus) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }



    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropietemp))
})


Restentropietemp = data.frame(Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsorttrenn = SumSDtemp 
EEE$indivbedsorttrenn = rowMeans(Entropieall)
Restentropie$indivbedsorttrenn = rowMeans(Restentropietemp)
RestentropieSD$indivbedsorttrenn = sd(Restentropietemp)
Restentropie
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropietemp = NULL
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    if (length(komus) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }



    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropietemp))
})


Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsorttrenn = SumSDtemp 
EEE$indivbedsorttrenn = rowMeans(Entropieall)
Restentropie$indivbedsorttrenn = rowMeans(Restentropietemp)
RestentropieSD$indivbedsorttrenn = (Restentropietemp)
#Restentropie
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropietemp = NULL
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    if (length(komus) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }



    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropietemp))
})


Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsorttrenn = SumSDtemp 
EEE$indivbedsorttrenn = rowMeans(Entropieall)
Restentropie$indivbedsorttrenn = rowMeans(Restentropietemp)
#RestentropieSD$indivbedsorttrenn = (Restentropietemp)
#Restentropie
'org_babel_R_eoe'
library(multicore)
library(foreach)
library(doMC)
registerDoMC(8)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()
############
#items = length(komus)
#persons = length(komus[,1])
items = 10
persons = 3
############

EEE = data.frame(matrix(ncol = 1, nrow = items))
SumSD = data.frame(matrix(ncol = 1, nrow = items))
RestEntropie = data.frame(matrix(ncol = 1, nrow = items))
RestEntropieSD = data.frame(matrix(ncol = 1, nrow = items))
names(EEE) = 'kill'
names(SumSD) = 'kill'
names(RestEntropie) = 'kill'
names(RestEntropieSD) = 'kill'
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropietemp = NULL
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    if (length(komus) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }



    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropietemp))
})


Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsorttrenn = SumSDtemp 
EEE$indivbedsorttrenn = rowMeans(Entropieall)
RestEntropie$indivbedsorttrenn = rowMeans(Restentropietemp)
RestEntropieSD$indivbedsorttrenn = (Restentropietemp)
RestEntropie
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropietemp = NULL
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    if (length(komus) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }



    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropietemp))
})


Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsorttrenn = SumSDtemp 
EEE$indivbedsorttrenn = rowMeans(Entropieall)
RestEntropie$indivbedsorttrenn = rowMeans(Restentropietemp)
RestEntropieSD$indivbedsorttrenn = (Restentropietemp)
RestEntropie
sd(Restentropietemp)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropietemp = NULL
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    if (length(komus) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }



    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropietemp))
})


Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsorttrenn = SumSDtemp 
EEE$indivbedsorttrenn = rowMeans(Entropieall)
RestEntropie$indivbedsorttrenn = rowMeans(Restentropietemp)
RestEntropieSD$indivbedsorttrenn = (Restentropietemp)
RestEntropie
apply(Restentropietemp, sd)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropietemp = NULL
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    if (length(komus) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }



    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropietemp))
})


Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsorttrenn = SumSDtemp 
EEE$indivbedsorttrenn = rowMeans(Entropieall)
RestEntropie$indivbedsorttrenn = rowMeans(Restentropietemp)
RestEntropieSD$indivbedsorttrenn = (Restentropietemp)
RestEntropie
apply(Restentropietemp,2 ,sd)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropietemp = NULL
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    if (length(komus) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }



    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropietemp))
})


Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsorttrenn = SumSDtemp 
EEE$indivbedsorttrenn = rowMeans(Entropieall)
RestEntropie$indivbedsorttrenn = rowMeans(Restentropietemp)
RestEntropieSD$indivbedsorttrenn = (Restentropietemp)
RestEntropie
apply(Restentropietemp,1 ,sd)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropietemp = NULL
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    if (length(komus) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }



    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropietemp))
})


Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsorttrenn = SumSDtemp 
EEE$indivbedsorttrenn = rowMeans(Entropieall)
RestEntropie$indivbedsorttrenn = rowMeans(Restentropietemp)
RestEntropieSD$indivbedsorttrenn = apply(Restentropietemp,1 ,sd)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropietemp = NULL
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    if (length(komus) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }



    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropietemp))
})


Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsorttrenn = SumSDtemp 
EEE$indivbedsorttrenn = rowMeans(Entropieall)
RestEntropie$indivbedsorttrenn = rowMeans(Restentropietemp)
RestEntropieSD$indivbedsorttrenn = apply(Restentropietemp,1 ,sd)
EEE['indivbedsorttenn']
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Restentropietemp = NULL
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

    }

    if (length(komus) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }



    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))


    
    return(c(Entropietemp, Restentropietemp))
})


Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsorttrenn = SumSDtemp 
EEE$indivbedsorttrenn = rowMeans(Entropieall)
RestEntropie$indivbedsorttrenn = rowMeans(Restentropietemp)
RestEntropieSD$indivbedsorttrenn = apply(Restentropietemp,1 ,sd)
EEE['indivbedsorttrenn']
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
Restentropietemp = NULL

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL

        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(mclapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
    }

    if (length(komus) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }

    chances = simplify2array(mclapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

    return(c(Entropietemp, Restentropietemp))
})

Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]

SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsort = SumSDtemp 
EEE$indivbedsort = rowMeans(Entropieall)
RestEntropie$indivbedsort = rowMeans(Restentropietemp)
RestEntropieSD$indivbedsort = apply(Restentropietemp,1 ,sd)
'org_babel_R_eoe'
################# Schlussberechnungen

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}
names(summe) = names(EEE)

if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}

benchmark
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(1:length(summe[,1]), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[names(summe[i])], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
    }
}

title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(1, length(summe[,1]), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
################# Schlussberechnungen

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}
names(summe) = names(EEE)

if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}

benchmark
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(1:length(summe[,1]), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[names(summe[i])], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
    }
}

title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(1, length(summe[,1]), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(1:length(summe[,1]), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
   # if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[names(summe[i])], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
   # }
}

title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(1, length(summe[,1]), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
################# Schlussberechnungen

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}
names(summe) = names(EEE)

if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}
RestEntropie
benchmark
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(1:length(summe[,1]), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
   # if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[1], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
   # }
}

title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(1, length(summe[,1]), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(1:length(summe[,1]), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
   # if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
#        lines(RestEntropie[1], col=farbe[i])
 #       lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
  #      lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
   # }
}
        lines(RestEntropie[1], col=farbe[i])


title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(1, length(summe[,1]), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
################# Schlussberechnungen

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}
names(summe) = names(EEE)

if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}
RestEntropie[1]
benchmark
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(1:length(summe[,1]), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
   # if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
#        lines(RestEntropie[1], col=farbe[i])
 #       lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
  #      lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
   # }
}
        lines(RestEntropie[,1], col=farbe[i])


title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(1, length(summe[,1]), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(1:length(summe[,1]), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(RestEntropie[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
   # if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
#        lines(RestEntropie[1], col=farbe[i])
 #       lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
  #      lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
   # }
}
        lines(RestEntropie[,1], col=farbe[i])


title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(1, length(summe[,1]), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
################# Schlussberechnungen

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}
names(summe) = names(EEE)

if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}
RestEntropie[,1]
benchmark
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(1:(length(summe[,1]*10)), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[1], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
    }
}
#        lines(RestEntropie[,1], col=farbe[i])


title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(1, length(summe[,1]), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(1:(length(summe[,1]+10)), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[1], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
    }
}
#        lines(RestEntropie[,1], col=farbe[i])


title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(1, length(summe[,1]), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(1:(length(summe[,1])*5), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[1], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
    }
}
#        lines(RestEntropie[,1], col=farbe[i])


title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(1, length(summe[,1]), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(1:(length(summe[,1])*5), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[1], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
    }
}
#        lines(RestEntropie[,1], col=farbe[i])


title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(2, length(summe[,1]), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(1:(length(summe[,1])*5), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[1], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
    }
}
#        lines(RestEntropie[,1], col=farbe[i])


title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(10, length(summe[,1]), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(1:(length(summe[,1])*5), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[1], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
    }
}
#        lines(RestEntropie[,1], col=farbe[i])


title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(20, length(summe[,1]), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(1:(length(komus)), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[1], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
    }
}
#        lines(RestEntropie[,1], col=farbe[i])


title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(20, length(komus), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(1:(length(komus)), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[1], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
    }
}
#        lines(RestEntropie[,1], col=farbe[i])


title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(length(komus)/5, length(komus), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(1:(length(komus)), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[1], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
    }
}
#        lines(RestEntropie[,1], col=farbe[i])


title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(length(komus)/5, length(komus), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(1:(length(komus)), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[i], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
    }
}
#        lines(RestEntropie[,1], col=farbe[i])


title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(length(komus)/5, length(komus), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(1:(length(komus)), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[i], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
    }
}
#        lines(RestEntropie[,1], col=farbe[i])


title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(length(komus)/5, length(komus), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(1:(length(komus)), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[i], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
    }
}
#        lines(RestEntropie[,1], col=farbe[i])


title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(length(komus)/5, length(komus), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
Restentropietemp = NULL
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

if (length(komus) == items) {
    Restentropietemp[items] = 0
} else {
    fitting = NULL
    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }
    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
    Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
}

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$durchschbedsort = SumSDtemp 
EEE$durchschbedsort = colMeans(Entropietemp)
RestEntropie$durchschbedsort = colMeans(Restentropietemp)
RestEntropieSD$durchschbedsort = apply(Restentropietemp,2 ,sd)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
Restentropietemp = NULL
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

if (length(komus) == items) {
    Restentropietemp[items] = 0
} else {
    fitting = NULL
    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }
    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(lapply(fitting, predict, type="response"))
    Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
}

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$durchschbedsort = SumSDtemp 
EEE$durchschbedsort = colMeans(Entropietemp)
RestEntropie$durchschbedsort = colMeans(Restentropietemp)
RestEntropieSD$durchschbedsort = apply(Restentropietemp,2 ,sd)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
Restentropietemp = NULL
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

if (length(komus) == items) {
    Restentropietemp[items] = 0
} else {
    fitting = NULL
    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }
    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(lapply(fitting, predict, type="response"))
    Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
}

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}
Restentropie
SumSD$durchschbedsort = SumSDtemp 
EEE$durchschbedsort = colMeans(Entropietemp)
RestEntropie$durchschbedsort = colMeans(Restentropietemp)
RestEntropieSD$durchschbedsort = apply(Restentropietemp,2 ,sd)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
Restentropietemp = NULL
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

if (length(komus) == items) {
    Restentropietemp[items] = 0
} else {
    fitting = NULL
    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }
    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(lapply(fitting, predict, type="response"))
    Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
}

simplify2array(Restentropie)
chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}
Restentropie
SumSD$durchschbedsort = SumSDtemp 
EEE$durchschbedsort = colMeans(Entropietemp)
RestEntropie$durchschbedsort = colMeans(Restentropietemp)
RestEntropieSD$durchschbedsort = apply(Restentropietemp,2 ,sd)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
Restentropietemp = NULL
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

if (length(komus) == items) {
    Restentropietemp[items] = 0
} else {
    fitting = NULL
    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }
    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(lapply(fitting, predict, type="response"))
    Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
}

simplify2array(Restentropietemp)
chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}
Restentropietemp
SumSD$durchschbedsort = SumSDtemp 
EEE$durchschbedsort = colMeans(Entropietemp)
RestEntropie$durchschbedsort = colMeans(Restentropietemp)
RestEntropieSD$durchschbedsort = apply(Restentropietemp,2 ,sd)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
Restentropietemp = NULL
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Restentropietemp[i-1] = rowSums(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

if (length(komus) == items) {
    Restentropietemp[items] = 0
} else {
    fitting = NULL
    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }
    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(lapply(fitting, predict, type="response"))
    Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
}

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}
Restentropietemp
SumSD$durchschbedsort = SumSDtemp 
EEE$durchschbedsort = colMeans(Entropietemp)
RestEntropie$durchschbedsort = colMeans(Restentropietemp)
RestEntropieSD$durchschbedsort = apply(Restentropietemp,2 ,sd)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
Restentropietemp = NULL
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
#    Restentropietemp[i-1] = rowSums(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 

    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}
Entropietemp

if (length(komus) == items) {
    Restentropietemp[items] = 0
} else {
    fitting = NULL
    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }
    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(lapply(fitting, predict, type="response"))
    Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
}

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}
Restentropietemp
SumSD$durchschbedsort = SumSDtemp 
EEE$durchschbedsort = colMeans(Entropietemp)
RestEntropie$durchschbedsort = colMeans(Restentropietemp)
RestEntropieSD$durchschbedsort = apply(Restentropietemp,2 ,sd)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
Restentropietemp = NULL
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
#    Restentropietemp[i-1] = rowSums(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 

    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}
chances

if (length(komus) == items) {
    Restentropietemp[items] = 0
} else {
    fitting = NULL
    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }
    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(lapply(fitting, predict, type="response"))
    Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
}

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}
Restentropietemp
SumSD$durchschbedsort = SumSDtemp 
EEE$durchschbedsort = colMeans(Entropietemp)
RestEntropie$durchschbedsort = colMeans(Restentropietemp)
RestEntropieSD$durchschbedsort = apply(Restentropietemp,2 ,sd)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
#Restentropietemp[[1]] = NULL
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Restentropietemp[[i-1]] = rowSums(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 

    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}
chances

if (length(komus) == items) {
    Restentropietemp[items] = 0
} else {
    fitting = NULL
    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }
    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(lapply(fitting, predict, type="response"))
    Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
}

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}
Restentropietemp
SumSD$durchschbedsort = SumSDtemp 
EEE$durchschbedsort = colMeans(Entropietemp)
RestEntropie$durchschbedsort = colMeans(Restentropietemp)
RestEntropieSD$durchschbedsort = apply(Restentropietemp,2 ,sd)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
Restentropietemp[[1]] = NULL
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Restentropietemp[[i-1]] = rowSums(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 

    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}
chances

if (length(komus) == items) {
    Restentropietemp[items] = 0
} else {
    fitting = NULL
    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }
    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(lapply(fitting, predict, type="response"))
    Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
}

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}
Restentropietemp
SumSD$durchschbedsort = SumSDtemp 
EEE$durchschbedsort = colMeans(Entropietemp)
RestEntropie$durchschbedsort = colMeans(Restentropietemp)
RestEntropieSD$durchschbedsort = apply(Restentropietemp,2 ,sd)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
Restentropietemp = NULL
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Restentropietemp[[i-1]] = rowSums(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 

    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}
chances

if (length(komus) == items) {
    Restentropietemp[items] = 0
} else {
    fitting = NULL
    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }
    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(lapply(fitting, predict, type="response"))
    Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
}

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}
Restentropietemp
SumSD$durchschbedsort = SumSDtemp 
EEE$durchschbedsort = colMeans(Entropietemp)
RestEntropie$durchschbedsort = colMeans(Restentropietemp)
RestEntropieSD$durchschbedsort = apply(Restentropietemp,2 ,sd)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
Restentropietemp = NULL
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Restentropietemp[[i-1]] = rowSums(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 

    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}
chances

if (length(komus) == items) {
    Restentropietemp[[items]] = 0
} else {
    fitting = NULL
    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }
    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(lapply(fitting, predict, type="response"))
    Restentropietemp[[length(fragen)]] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
}
simplify2array(Restentropietemp)
chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}
Restentropietemp
SumSD$durchschbedsort = SumSDtemp 
EEE$durchschbedsort = colMeans(Entropietemp)
RestEntropie$durchschbedsort = colMeans(Restentropietemp)
RestEntropieSD$durchschbedsort = apply(Restentropietemp,2 ,sd)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
Restentropietemp = NULL
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Restentropietemp[[i-1]] = rowSums(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 

    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

if (length(komus) == items) {
    Restentropietemp[[items]] = 0
} else {
    fitting = NULL
    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }
    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(lapply(fitting, predict, type="response"))
    Restentropietemp[[length(fragen)]] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
}
simplify2array(Restentropietemp)
chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}
Restentropietemp
SumSD$durchschbedsort = SumSDtemp 
EEE$durchschbedsort = colMeans(Entropietemp)
RestEntropie$durchschbedsort = colMeans(Restentropietemp)
RestEntropieSD$durchschbedsort = apply(Restentropietemp,2 ,sd)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
Restentropietemp = NULL
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Restentropietemp[[i-1]] = rowSums(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 

    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

if (length(komus) == items) {
    Restentropietemp[[items]] = 0
} else {
    fitting = NULL
    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }
    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(lapply(fitting, predict, type="response"))
    Restentropietemp[[length(fragen)]] = rowSums(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
}
simplify2array(Restentropietemp)
chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}
Restentropietemp
SumSD$durchschbedsort = SumSDtemp 
EEE$durchschbedsort = colMeans(Entropietemp)
RestEntropie$durchschbedsort = colMeans(Restentropietemp)
RestEntropieSD$durchschbedsort = apply(Restentropietemp,2 ,sd)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
Restentropietemp = NULL
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Restentropietemp[[i-1]] = rowSums(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 

    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

if (length(komus) == items) {
    Restentropietemp[[items]] = 0
} else {
    fitting = NULL
    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }
    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(lapply(fitting, predict, type="response"))
    Restentropietemp[[length(fragen)]] = rowSums(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
}
simplify2array(Restentropietemp)
chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$durchschbedsort = SumSDtemp 
EEE$durchschbedsort = colMeans(Entropietemp)
RestEntropie$durchschbedsort = colMeans(Restentropietemp)
RestEntropieSD$durchschbedsort = apply(Restentropietemp,2 ,sd)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
Restentropietemp = NULL
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Restentropietemp[[i-1]] = rowSums(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 

    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

if (length(komus) == items) {
    Restentropietemp[[items]] = 0
} else {
    fitting = NULL
    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }
    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(lapply(fitting, predict, type="response"))
    Restentropietemp[[length(fragen)]] = rowSums(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
}
Restentroipetemp = simplify2array(Restentropietemp)
chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$durchschbedsort = SumSDtemp 
EEE$durchschbedsort = colMeans(Entropietemp)
RestEntropie$durchschbedsort = colMeans(Restentropietemp)
RestEntropieSD$durchschbedsort = apply(Restentropietemp,2 ,sd)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
Restentropietemp = NULL
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Restentropietemp[[i-1]] = rowSums(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 

    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

if (length(komus) == items) {
    Restentropietemp[[items]] = 0
} else {
    fitting = NULL
    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }
    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(lapply(fitting, predict, type="response"))
    Restentropietemp[[length(fragen)]] = rowSums(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
}
Restentroipetemp = simplify2array(Restentropietemp)
Restentropietemp
chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$durchschbedsort = SumSDtemp 
EEE$durchschbedsort = colMeans(Entropietemp)
RestEntropie$durchschbedsort = colMeans(Restentropietemp)
RestEntropieSD$durchschbedsort = apply(Restentropietemp,2 ,sd)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
Restentropietemp = NULL
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Restentropietemp[[i-1]] = rowSums(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 

    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

if (length(komus) == items) {
    Restentropietemp[[items]] = 0
} else {
    fitting = NULL
    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }
    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(lapply(fitting, predict, type="response"))
    Restentropietemp[[length(fragen)]] = rowSums(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
}
Restentropietemp = simplify2array(Restentropietemp)
#Restentropietemp
chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$durchschbedsort = SumSDtemp 
EEE$durchschbedsort = colMeans(Entropietemp)
RestEntropie$durchschbedsort = colMeans(Restentropietemp)
RestEntropieSD$durchschbedsort = apply(Restentropietemp,2 ,sd)
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(1:(length(komus)), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[i], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
    }
}

title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(length(komus)/5, length(komus), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
################# Schlussberechnungen

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}
names(summe) = names(EEE)

if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}
benchmark
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(1:(length(komus)), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[i], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
    }
}

title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(length(komus)/5, length(komus), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
################# Schlussberechnungen

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}
names(summe) = names(EEE)
summe
if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}
benchmark
'org_babel_R_eoe'
################# Schlussberechnungen

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}
names(summe) = names(EEE)
rbind(0,summe)
if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}
benchmark
'org_babel_R_eoe'
################# Schlussberechnungen

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}
names(summe) = names(EEE)
rbind(0,summe)
if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}
benchmark
'org_babel_R_eoe'
################# Schlussberechnungen

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}
names(summe) = names(EEE)
rbind(0,summe)
EEE[1]
if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}
benchmark
'org_babel_R_eoe'
################# Schlussberechnungen

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}
names(summe) = names(EEE)
rbind(0,summe)
EEE[1,1]
if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}
benchmark
'org_babel_R_eoe'
################# Schlussberechnungen

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}
names(summe) = names(EEE)
rbind(0,summe)
EEE[1,1] == 0
if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}
benchmark
'org_babel_R_eoe'
################# Schlussberechnungen

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}
names(summe) = names(EEE)
rbind(0,summe)
EEE[1,1] != 0
if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}
benchmark
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(0:(length(komus)), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[i], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
    }
}

title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(length(komus)/5, length(komus), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
################# Schlussberechnungen

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}
names(summe) = names(EEE)
rbind(0,summe)
if (EEE[1,1] != 0) {
    summe = rbind(0,summe)
    SumSD = rbind(0,SumSD)
    RestEntropie = rbind(0,Restentropie)
    RestEntropieSD = rbind(0,RestentropieSD)
}
if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}
benchmark
'org_babel_R_eoe'
################# Schlussberechnungen

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}
names(summe) = names(EEE)
rbind(0,summe)
if (EEE[1,1] != 0) {
    summe = rbind(0,summe)
    SumSD = rbind(0,SumSD)
    RestEntropie = rbind(0,RestEntropie)
    RestEntropieSD = rbind(0,RestEntropieSD)
}
if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}
benchmark
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
Restentropietemp = NULL

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL

        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(mclapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
    }

    if (length(komus) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }

    chances = simplify2array(mclapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

    return(c(Entropietemp, Restentropietemp))
})

Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]

SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsort = SumSDtemp 
EEE$indivbedsort = rowMeans(Entropieall)
RestEntropie$indivbedsort = rowMeans(Restentropietemp)
RestEntropieSD$indivbedsort = apply(Restentropietemp,1 ,sd)
'org_babel_R_eoe'
library(multicore)
library(foreach)
library(doMC)
registerDoMC(8)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()
############
#items = length(komus)
#persons = length(komus[,1])
items = 10
persons = 3
############

EEE = data.frame(matrix(ncol = 1, nrow = items))
SumSD = data.frame(matrix(ncol = 1, nrow = items))
RestEntropie = data.frame(matrix(ncol = 1, nrow = items))
RestEntropieSD = data.frame(matrix(ncol = 1, nrow = items))
names(EEE) = 'kill'
names(SumSD) = 'kill'
names(RestEntropie) = 'kill'
names(RestEntropieSD) = 'kill'
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
Restentropietemp = NULL
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Restentropietemp[[i-1]] = rowSums(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 

    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

if (length(komus) == items) {
    Restentropietemp[[items]] = 0
} else {
    fitting = NULL
    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }
    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(lapply(fitting, predict, type="response"))
    Restentropietemp[[length(fragen)]] = rowSums(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
}
Restentropietemp = simplify2array(Restentropietemp)

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$durchschbedsort = SumSDtemp 
EEE$durchschbedsort = colMeans(Entropietemp)
RestEntropie$durchschbedsort = colMeans(Restentropietemp)
RestEntropieSD$durchschbedsort = apply(Restentropietemp,2 ,sd)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
Restentropietemp = NULL

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL

        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(mclapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
    }

    if (length(komus) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }

    chances = simplify2array(mclapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

    return(c(Entropietemp, Restentropietemp))
})

Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]

SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsort = SumSDtemp 
EEE$indivbedsort = rowMeans(Entropieall)
RestEntropie$indivbedsort = rowMeans(Restentropietemp)
RestEntropieSD$indivbedsort = apply(Restentropietemp,1 ,sd)
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL
Restentropietemp = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
    }

    if (length(komus) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    
    return(c(Entropietemp, Restentropietemp))
})

Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsorttrenn = SumSDtemp 
EEE$indivbedsorttrenn = rowMeans(Entropieall)
RestEntropie$indivbedsorttrenn = rowMeans(Restentropietemp)
RestEntropieSD$indivbedsorttrenn = apply(Restentropietemp,1 ,sd)
'org_babel_R_eoe'
################# Schlussberechnungen

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}
names(summe) = names(EEE)
rbind(0,summe)
#if (EEE[1,1] != 0) {
 #   summe = rbind(0,summe)
  #  SumSD = rbind(0,SumSD)
   # RestEntropie = rbind(0,RestEntropie)
    #RestEntropieSD = rbind(0,RestEntropieSD)
#}
if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}
benchmark
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(0:(length(komus)), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[i], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
    }
}

title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(length(komus)/5, length(komus), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
library(multicore)
library(foreach)
library(doMC)
registerDoMC(8)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()
############
#items = length(komus)
#persons = length(komus[,1])
items = 10
persons = 3
############

EEE = data.frame(matrix(ncol = 1, nrow = items+1))
SumSD = data.frame(matrix(ncol = 1, nrow = items+1))
RestEntropie = data.frame(matrix(ncol = 1, nrow = items+1))
RestEntropieSD = data.frame(matrix(ncol = 1, nrow = items+1))
names(EEE) = 'kill'
names(SumSD) = 'kill'
names(RestEntropie) = 'kill'
names(RestEntropieSD) = 'kill'
'org_babel_R_eoe'
############## Bedingte und undbedingte Entropie in normaler Reihenfolge
modell[[1]] = glm(V1 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$bedunsort = SumSDtemp 

EEE$bedunsort = c(0,colMeans(Entropietemp))
EEE$unbedunsort = c(0,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
EEE$unbedsort = c(0,sort(EEE$unbedunsort, decreasing = TRUE))
'org_babel_R_eoe'
library(multicore)
library(foreach)
library(doMC)
registerDoMC(8)
calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()
############
#items = length(komus)
#persons = length(komus[,1])
items = 10
persons = 3
############

EEE = data.frame(matrix(ncol = 1, nrow = items+1))
SumSD = data.frame(matrix(ncol = 1, nrow = items+1))
RestEntropie = data.frame(matrix(ncol = 1, nrow = items+1))
RestEntropieSD = data.frame(matrix(ncol = 1, nrow = items+1))
names(EEE) = 'kill'
names(SumSD) = 'kill'
names(RestEntropie) = 'kill'
names(RestEntropieSD) = 'kill'
EEE
'org_babel_R_eoe'
############## Bedingte und undbedingte Entropie in normaler Reihenfolge
modell[[1]] = glm(V1 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$bedunsort = c(0,SumSDtemp)

EEE$bedunsort = c(0,colMeans(Entropietemp))
EEE$unbedunsort = c(0,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
EEE$unbedsort = c(0,sort(EEE$unbedunsort, decreasing = TRUE))
'org_babel_R_eoe'
############## Bedingte und undbedingte Entropie in normaler Reihenfolge
modell[[1]] = glm(V1 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$bedunsort = c(0,SumSDtemp)

EEE$bedunsort = c(0,colMeans(Entropietemp))
EEE$unbedunsort = c(0,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
EEE$unbedsort = sort(EEE$unbedunsort, decreasing = TRUE)
'org_babel_R_eoe'
############### Bedingte Entropie in über den Durchschnitt sortierten Reihenfolge
komus2 = komus[c(names(sort(-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2), decreasing = TRUE)))]
modell[[1]] = glm(V1 ~ 1, data = komus2, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus2[1:i-1]), names(komus2[i])), data = komus2, family = "binomial"(link=logit))
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$sortbed = c(0,SumSDtemp)

EEE$sortbed = c(0,colMeans(Entropietemp))
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder durchschnittlichen Antwort
Restentropietemp = NULL
fragen = c(44)

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Restentropietemp[[i-1]] = rowSums(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 

    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

if (length(komus) == items) {
    Restentropietemp[[items]] = 0
} else {
    fitting = NULL
    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }
    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(lapply(fitting, predict, type="response"))
    Restentropietemp[[length(fragen)]] = rowSums(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
}
Restentropietemp = simplify2array(Restentropietemp)

chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$durchschbedsort = c(0,SumSDtemp)
EEE$durchschbedsort = c(0,colMeans(Entropietemp))
RestEntropie$durchschbedsort = c(0,colMeans(Restentropietemp))
RestEntropieSD$durchschbedsort = c(0,apply(Restentropietemp, 2, sd))
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
Restentropietemp = NULL

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))

Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL

        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(mclapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
    }

    if (length(komus) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }

    chances = simplify2array(mclapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

    return(c(Entropietemp, Restentropietemp))
})

Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]

SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsort = c(0,SumSDtemp)
EEE$indivbedsort = c(0,rowMeans(Entropieall))
RestEntropie$indivbedsort = c(0,rowMeans(Restentropietemp))
RestEntropieSD$indivbedsort = c(0,apply(Restentropietemp, 1, sd))
'org_babel_R_eoe'
####### Bedingte Entropie, sortiert nach jeder individuellen Antwort
Entropieall = NULL
chances = NULL
beta = NULL
Restentropietemp = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

modell[[1]] = glm(V44 ~ 1, data = komus, family = "binomial"(link=logit))
Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = c(44)
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
    }

    if (length(komus) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    
    return(c(Entropietemp, Restentropietemp))
})

Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsorttrenn = c(0,SumSDtemp )
EEE$indivbedsorttrenn = c(0,rowMeans(Entropieall))
RestEntropie$indivbedsorttrenn = c(0,rowMeans(Restentropietemp))
RestEntropieSD$indivbedsorttrenn = c(0,apply(Restentropietemp,1 ,sd))
'org_babel_R_eoe'
################# Schlussberechnungen

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}
names(summe) = names(EEE)
rbind(0,summe)
#if (EEE[1,1] != 0) {
 #   summe = rbind(0,summe)
  #  SumSD = rbind(0,SumSD)
   # RestEntropie = rbind(0,RestEntropie)
    #RestEntropieSD = rbind(0,RestEntropieSD)
#}
if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}
benchmark
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(0:(length(komus)), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[i], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
    }
}

title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(length(komus)/5, length(komus), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
################# Schlussberechnungen

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}
names(summe) = names(EEE)
RestEntropie
#if (EEE[1,1] != 0) {
 #   summe = rbind(0,summe)
  #  SumSD = rbind(0,SumSD)
   # RestEntropie = rbind(0,RestEntropie)
    #RestEntropieSD = rbind(0,RestEntropieSD)
#}
if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}
benchmark
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(0:(length(komus)), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
lines(RestEntropie[1], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[i], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
    }
}

title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(length(komus)/5, length(komus), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
for (j in 1:(length(summe[1,]))) {
    farbe[j] = rgb(runif(1, 0, 1), runif(1, 0, 1), runif(1, 0, 1))
}

plot(0:(length(komus)), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])

    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbe[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[i], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbe[i])
#    }
}

title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(length(komus)/5, length(komus), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
