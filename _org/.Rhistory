ENTtemp = NULL
multifragen[multifragen<30]
chances[-multifragen] = mclapply(fitting[-multifragen], predict, type="response")
chances[multifragen] = mclapply(fitting[multifragen], predict, type="probs")

EntropieFrame = chances

EntropieFrame[multifragen] = lapply(chances[multifragen], FUN.EntropieMC)
EntropieFrame[-multifragen] =lapply(chances[-multifragen], FUN.Entropie)
EntropieFrame = simplify2array(EntropieFrame)
EntropieFrame













'org_babel_R_eoe'
calculationtime <- proc.time()
modell = NULL





modell[[1]] = glm(reformulate('1', names(komusmult[1])), data = komusmult, family = "binomial"(link=logit))

for (i in 2:items) {
    if (i %in% multifragen) {
        modell[[i]] = polr(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult)
    } else {
        modell[[i]] = glm(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult, family = "binomial"(link=logit))
    }
}
fitting = modell
chances = fitting
chances[-multifragen] = mclapply(fitting[-multifragen], predict, type="response")
chances[multifragen] = mclapply(fitting[multifragen], predict, type="probs")

Entropietemp = fitting

Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC)
Entropietemp[-multifragen] =lapply(chances[-multifragen], FUN.Entropie)
Entropietemp = simplify2array(Entropietemp)

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$bedunsort = c(0,SumSDtemp)

EEE$bedunsort = c(0,colMeans(Entropietemp))
EEE$unbedunsort = c(0,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
EEE$unbedsort = c(0,sort(-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2),decreasing =TRUE))






modell[[1]] = glm(reformulate('1', names(komusmult[1])), data = komusmult, family = "binomial"(link=logit))

for (i in 2:51) {

}
fitting = modell
chances = fitting
ENTtemp = NULL
multifragen[multifragen<30]
chances[-multifragen] = mclapply(fitting[-multifragen], predict, type="response")
chances[multifragen] = mclapply(fitting[multifragen], predict, type="probs")

EntropieFrame = chances

EntropieFrame[multifragen] = lapply(chances[multifragen], FUN.EntropieMC)
EntropieFrame[-multifragen] =lapply(chances[-multifragen], FUN.Entropie)
EntropieFrame = simplify2array(EntropieFrame)
EntropieFrame













'org_babel_R_eoe'

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}

RestEntropie[1,] = sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2))

names(summe) = names(EEE)

if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}

RestEntropie

benchmark
RestEntropieSD
'org_babel_R_eoe'
png(filename="/images/entropie2.png")
require(MASS)
library(multicore)
library(foreach)
library(doMC)
registerDoMC(8)

calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
komusmult = data.frame(read.table("data/komus.csv",header=TRUE, sep=','))
multifragen = array(which(sapply(komusmult, max) > 1))
komusmult[multifragen] = lapply(komusmult[multifragen],factor)

FUN.EntropieMC = function(x) {return(rowSums(-x*log(x,2)))}
FUN.Entropie = function(x) {return(-x*log(x, 2)-(1-x)*log(1-x, 2))}

Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()
persons = length(komus[,1])
items = 50

EEE = data.frame(matrix(ncol = 1, nrow = items+1))
SumSD = data.frame(matrix(ncol = 1, nrow = items+1))
RestEntropie = data.frame(matrix(ncol = 1, nrow = items+1))
RestEntropieSD = data.frame(matrix(ncol = 1, nrow = items+1))
names(EEE) = 'kill'
names(SumSD) = 'kill'
names(RestEntropie) = 'kill'
names(RestEntropieSD) = 'kill'
modell[[1]] = glm(reformulate('1', names(komus[1])), data = komus2, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus[1:i-1]), names(komus[i])), data = komus, family = "binomial"(link=logit))
}
fitting = modell
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$bedunsort = c(0,SumSDtemp)

EEE$bedunsort = c(0,colMeans(Entropietemp))
EEE$unbedunsort = c(0,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
EEE$unbedsort = c(0,sort(-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2),decreasing =TRUE))


komus2 = komus[c(names(sort(-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2), decreasing = TRUE)))]



modell[[1]] = glm(reformulate('1', names(komus2[1])), data = komus2, family = "binomial"(link=logit))

for (i in 2:items) {
    modell[[i]] = glm(reformulate(names(komus2[1:i-1]), names(komus2[i])), data = komus2, family = "binomial"(link=logit))
}
fitting = modell
chances = simplify2array(mclapply(fitting, predict, type="response"))
Entropietemp = -chances*log(chances,2)-(1-chances)*log(1-chances,2)

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$sortbed = c(0,SumSDtemp)

EEE$sortbed = c(0,colMeans(Entropietemp))

Restentropietemp = NULL

for (j in 1:length(komus)) {
    fitting[[j]] = glm(reformulate('1', names(komus[j])), data = komus, family = "binomial"(link=logit))
}
chances = simplify2array(lapply(fitting, predict, komus[1,], type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information)
fragen = which(names(komus[which((Entropietemp) == max((Entropietemp)))]) == names(komus))

modell[[1]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

for (i in 2:items) {
    Entropietemp = NULL
    fitting = NULL

    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }

    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(mclapply(fitting, predict, type="response"))
    Restentropietemp[[i-1]] = rowSums(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 

    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

    fragen = c(fragen, which(names(komus[-fragen][which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]) == names(komus)))
    modell[[i]] = fitting[[which(colMeans(Entropietemp) == max(colMeans(Entropietemp)))]]
}

if (length(komus) == items) {
    Restentropietemp[[items]] = Restentropietemp[[1]]*0
} else {
    fitting = NULL
    for (j in 1:length(komus[-fragen])) {
        fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
    }
    #fitting = mclapply(fitting, step, trace = 0)
    #fitting = mclapply(fitting, step, ~.^2, trace = 0)
    chances = simplify2array(lapply(fitting, predict, type="response"))
    Restentropietemp[[length(fragen)]] = rowSums(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
}

Restentropietemp = simplify2array(Restentropietemp)
chances = simplify2array(mclapply(modell, predict, type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$durchschbedsort = c(0,SumSDtemp)
EEE$durchschbedsort = c(0,colMeans(Entropietemp))
RestEntropie$durchschbedsort = c(0,colMeans(Restentropietemp))
RestEntropieSD$durchschbedsort = c(0,apply(Restentropietemp, 2, sd))
Entropieall = NULL
chances = NULL
Restentropietemp = NULL



for (j in 1:length(komus)) {
    fitting[[j]] = glm(reformulate('1', names(komus[j])), data = komus, family = "binomial"(link=logit))
}
chances = simplify2array(lapply(fitting, predict, komus[1,], type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
frageninit = which(names(komus[which((Entropietemp) == max((Entropietemp)))]) == names(komus))

modell[[1]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = frageninit
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL

        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(mclapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
    }

    if (length(komus) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }

    chances = simplify2array(mclapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))

    return(c(Entropietemp, Restentropietemp))
})

Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]

SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsort = c(0,SumSDtemp)
EEE$indivbedsort = c(0,rowMeans(Entropieall))
RestEntropie$indivbedsort = c(0,rowMeans(Restentropietemp))
RestEntropieSD$indivbedsort = c(0,apply(Restentropietemp, 1, sd))
Entropieall = NULL
chances = NULL
beta = NULL
Restentropietemp = NULL
Entropietemp = NULL
fitting = NULL

if (!exists("information")) {
    information = simplify2array(foreach(m=1:length(komus)) %dopar% {
        for (n in 1:(length(komus)-1)) {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        chances = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
        information = sum(colMeans(Entropietemp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}





for (j in 1:length(komus)) {
    fitting[[j]] = glm(reformulate('1', names(komus[j])), data = komus, family = "binomial"(link=logit))
}
chances = simplify2array(lapply(fitting, predict, komus[1,], type="response"))
Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information)
frageninit = which(names(komus[which((Entropietemp) == max((Entropietemp)))]) == names(komus))

 

modell[[1]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]

Entropieall = simplify2array(foreach(k=1:persons) %dopar% {
    fragen = frageninit
    for (i in 2:items) {
        Entropietemp = NULL
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }

        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        ## TODO stimmt das so?
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[i-1] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2)) 
        Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2)) + (information[-fragen]*(1 - (length(fragen)+1)/items))
        fragen = c(fragen, which(names(komus[-fragen][which((Entropietemp) == max((Entropietemp)))]) == names(komus)))
        modell[[i]] = fitting[[which((Entropietemp) == max((Entropietemp)))]]
    }

    if (length(komus) == items) {
        Restentropietemp[items] = 0
    } else {
        fitting = NULL
        for (j in 1:length(komus[-fragen])) {
            fitting[[j]] = glm(reformulate(names(komus[fragen]), names(komus[-fragen][j])), data = komus, family = "binomial"(link=logit))
        }
        #fitting = mclapply(fitting, step, trace = 0)
        #fitting = mclapply(fitting, step, ~.^2, trace = 0)
        chances = simplify2array(lapply(fitting, predict, komus[k,], type="response"))
        Restentropietemp[length(fragen)] = sum(-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    }

    chances = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    Entropietemp = (-chances*log(chances,2)-(1-chances)*log(1-chances,2))
    
    return(c(Entropietemp, Restentropietemp))
})

Restentropietemp = (Entropieall[(items+1):(items*2),])
Entropieall = Entropieall[1:items,]
SumSDtemp = sd(Entropieall[1,])
for (i in 2:length(Entropieall[,1])) {
SumSDtemp[i] = sd(colSums(Entropieall[1:i,]))
}

SumSD$indivbedsorttrenn = c(0,SumSDtemp )
EEE$indivbedsorttrenn = c(0,rowMeans(Entropieall))
RestEntropie$indivbedsorttrenn = c(0,rowMeans(Restentropietemp))
RestEntropieSD$indivbedsorttrenn = c(0,apply(Restentropietemp,1 ,sd))


if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}

RestEntropie[1,] = sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2))

names(summe) = names(EEE)

if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}

RestEntropie

benchmark
RestEntropieSD

farbe = NULL
farbeSD = NULL
for (j in 1:(length(summe[1,]))) {
    r = runif(1,0.1,0.9)
    g = runif(1,0.1,0.9)
    b = runif(1,0.1,0.9)
    farbe[j] = rgb(r^1.2, g^1.2, b^1.2)
    farbeSD[j] = rgb(sqrt(r), sqrt(g), sqrt(b))
}

plot(0:(length(komus)), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbeSD[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbeSD[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[names(summe[i])], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbeSD[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbeSD[i])
    }
}

title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(length(komus)/4, length(komus), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
############## Bedingte und undbedingte Entropie in normaler Reihenfolge

modell[[1]] = glm(reformulate('1', names(komusmult[1])), data = komusmult, family = "binomial"(link=logit))

for (i in 2:items) {
    if (i %in% multifragen) {
        modell[[i]] = polr(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult)
    } else {
        modell[[i]] = glm(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult, family = "binomial"(link=logit))
    }
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = fitting
chances[-multifragen] = mclapply(fitting[-multifragen], predict, type="response")
chances[multifragen] = mclapply(fitting[multifragen], predict, type="probs")

Entropietemp = fitting

Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC)
Entropietemp[-multifragen] =lapply(chances[-multifragen], FUN.Entropie)
Entropietemp = simplify2array(Entropietemp)

### Without relations ###
modell = lapply(modell, update, ~ 1)
chances[-multifragen] = mclapply(fitting[-multifragen], predict, type="response")
chances[multifragen] = mclapply(fitting[multifragen], predict, type="probs")
#c(sapply(chances[multifragen], FUN.EntropieMC), sapply(fitting[-multifragen], predict, type="response"))


SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$bedunsort = c(0,SumSDtemp)


EEE$bedunsort = c(0,colMeans(Entropietemp))
EEE$unbedunsort = c(0,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
EEE$unbedsort = c(0,sort(-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2),decreasing =TRUE))
'org_babel_R_eoe'
require(MASS)
library(multicore)
library(foreach)
library(doMC)
registerDoMC(8)

calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
komusmult = data.frame(read.table("data/komus.csv",header=TRUE, sep=','))
multifragen = array(which(sapply(komusmult, max) > 1))
komusmult[multifragen] = lapply(komusmult[multifragen],factor)

FUN.EntropieMC = function(x) {return(rowSums(-x*log(x,2)))}
FUN.Entropie = function(x) {return(-x*log(x, 2)-(1-x)*log(1-x, 2))}

Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()
############
#items = length(komus)
persons = length(komus[,1])
items = 50
#persons = 50
############

EEE = data.frame(matrix(ncol = 1, nrow = items+1))
SumSD = data.frame(matrix(ncol = 1, nrow = items+1))
RestEntropie = data.frame(matrix(ncol = 1, nrow = items+1))
RestEntropieSD = data.frame(matrix(ncol = 1, nrow = items+1))
names(EEE) = 'kill'
names(SumSD) = 'kill'
names(RestEntropie) = 'kill'
names(RestEntropieSD) = 'kill'
'org_babel_R_eoe'
############## Bedingte und undbedingte Entropie in normaler Reihenfolge

modell[[1]] = glm(reformulate('1', names(komusmult[1])), data = komusmult, family = "binomial"(link=logit))

for (i in 2:items) {
    if (i %in% multifragen) {
        modell[[i]] = polr(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult)
    } else {
        modell[[i]] = glm(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult, family = "binomial"(link=logit))
    }
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = fitting
chances[-multifragen] = mclapply(fitting[-multifragen], predict, type="response")
chances[multifragen] = mclapply(fitting[multifragen], predict, type="probs")

Entropietemp = fitting

Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC)
Entropietemp[-multifragen] =lapply(chances[-multifragen], FUN.Entropie)
Entropietemp = simplify2array(Entropietemp)

### Without relations ###
modell = lapply(modell, update, ~ 1)
chances2 = modell
chances2[-multifragen] = mclapply(modell[-multifragen], predict, type="response")
chances2[multifragen] = mclapply(modell[multifragen], predict, type="probs")
Entropietemp2 = modell
Entropietemp2[multifragen] = lapply(chances2[multifragen], FUN.EntropieMC)
Entropietemp2[-multifragen] =lapply(chances2[-multifragen], FUN.Entropie)
Entropietemp2 = simplify2array(Entropietemp2)
#c(sapply(chances[multifragen], FUN.EntropieMC), sapply(fitting[-multifragen], predict, type="response"))


SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$bedunsort = c(0,SumSDtemp)


EEE$bedunsort = c(0,colMeans(Entropietemp))
EEE$unbedunsort = c(0,-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2))
EEE$unbedsort = c(0,sort(-colMeans(komus[1:items])*log(colMeans(komus[1:items]),2)-(1-colMeans(komus[1:items]))*log(1-colMeans(komus[1:items]),2),decreasing =TRUE))
'org_babel_R_eoe'
############## Bedingte und undbedingte Entropie in normaler Reihenfolge

modell[[1]] = glm(reformulate('1', names(komusmult[1])), data = komusmult, family = "binomial"(link=logit))

for (i in 2:items) {
    if (i %in% multifragen) {
        modell[[i]] = polr(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult)
    } else {
        modell[[i]] = glm(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult, family = "binomial"(link=logit))
    }
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = fitting
chances[-multifragen] = mclapply(fitting[-multifragen], predict, type="response")
chances[multifragen] = mclapply(fitting[multifragen], predict, type="probs")

Entropietemp = fitting

Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC)
Entropietemp[-multifragen] =lapply(chances[-multifragen], FUN.Entropie)
Entropietemp = simplify2array(Entropietemp)

### Without relations ###
modell = lapply(modell, update, ~ 1)
chances2 = modell
chances2[-multifragen] = mclapply(modell[-multifragen], predict, type="response")
chances2[multifragen] = mclapply(modell[multifragen], predict, type="probs")
Entropietemp2 = modell
Entropietemp2[multifragen] = lapply(chances2[multifragen], FUN.EntropieMC)
Entropietemp2[-multifragen] =lapply(chances2[-multifragen], FUN.Entropie)
Entropietemp2 = simplify2array(Entropietemp2)
#c(sapply(chances[multifragen], FUN.EntropieMC), sapply(fitting[-multifragen], predict, type="response"))


SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$bedunsort = c(0,SumSDtemp)


EEE$bedunsort = c(0,colMeans(Entropietemp))
EEE$unbedunsort = c(0,colMeans(Entropietemp2))
EEE$unbedsort = c(0,sort(Entropietemp2, decreasing =TRUE))
'org_babel_R_eoe'
############## Bedingte und undbedingte Entropie in normaler Reihenfolge

modell[[1]] = glm(reformulate('1', names(komusmult[1])), data = komusmult, family = "binomial"(link=logit))

for (i in 2:items) {
    if (i %in% multifragen) {
        modell[[i]] = polr(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult)
    } else {
        modell[[i]] = glm(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult, family = "binomial"(link=logit))
    }
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = fitting
chances[-multifragen] = mclapply(fitting[-multifragen], predict, type="response")
chances[multifragen] = mclapply(fitting[multifragen], predict, type="probs")

Entropietemp = fitting

Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC)
Entropietemp[-multifragen] =lapply(chances[-multifragen], FUN.Entropie)
Entropietemp = simplify2array(Entropietemp)

### Without relations ###
modell = lapply(modell, update, ~ 1)
chances2 = modell
chances2[-multifragen] = mclapply(modell[-multifragen], predict, type="response")
chances2[multifragen] = mclapply(modell[multifragen], predict, type="probs")
Entropietemp2 = modell
Entropietemp2[multifragen] = lapply(chances2[multifragen], FUN.EntropieMC)
Entropietemp2[-multifragen] =lapply(chances2[-multifragen], FUN.Entropie)
Entropietemp2 = simplify2array(Entropietemp2)
#c(sapply(chances[multifragen], FUN.EntropieMC), sapply(fitting[-multifragen], predict, type="response"))


SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$bedunsort = c(0,SumSDtemp)


EEE$bedunsort = c(0,colMeans(Entropietemp))
EEE$unbedunsort = c(0,colMeans(Entropietemp2))
EEE$unbedsort = c(0,sort(colMeans(Entropietemp2), decreasing =TRUE))
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
farbeSD = NULL
for (j in 1:(length(summe[1,]))) {
    r = runif(1,0.1,0.9)
    g = runif(1,0.1,0.9)
    b = runif(1,0.1,0.9)
    farbe[j] = rgb(r^1.2, g^1.2, b^1.2)
    farbeSD[j] = rgb(sqrt(r), sqrt(g), sqrt(b))
}

plot(0:(length(komus)), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbeSD[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbeSD[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[names(summe[i])], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbeSD[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbeSD[i])
    }
}

title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(length(komus)/4, length(komus), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
################# Schlussberechnungen

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}

RestEntropie[1,] = sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2))

names(summe) = names(EEE)

if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}

RestEntropie

benchmark
RestEntropieSD
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
farbeSD = NULL
for (j in 1:(length(summe[1,]))) {
    r = runif(1,0.1,0.9)
    g = runif(1,0.1,0.9)
    b = runif(1,0.1,0.9)
    farbe[j] = rgb(r^1.2, g^1.2, b^1.2)
    farbeSD[j] = rgb(sqrt(r), sqrt(g), sqrt(b))
}

plot(0:(length(komus)), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbeSD[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbeSD[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[names(summe[i])], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbeSD[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbeSD[i])
    }
}

title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(length(komus)/4, length(komus), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
farbeSD = NULL
for (j in 1:(length(summe[1,]))) {
    r = runif(1,0.1,0.9)
    g = runif(1,0.1,0.9)
    b = runif(1,0.1,0.9)
    farbe[j] = rgb(r^1.2, g^1.2, b^1.2)
    farbeSD[j] = rgb(sqrt(r), sqrt(g), sqrt(b))
}

plot(0:(length(komusmult)), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbeSD[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbeSD[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[names(summe[i])], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbeSD[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbeSD[i])
    }
}

title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(length(komus)/4, length(komus), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
################# Schlussberechnungen

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}

RestEntropie[1,] = sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2))

names(summe) = names(EEE)

if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}

RestEntropie
summe
benchmark
RestEntropieSD
'org_babel_R_eoe'
################# Schlussberechnungen

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}

RestEntropie[1,] = sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2))

names(summe) = names(EEE)

if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}

RestEntropie
EEE
benchmark
RestEntropieSD
'org_babel_R_eoe'
################# Schlussberechnungen

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}

RestEntropie[1,] = sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2))

names(summe) = names(EEE)

if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}


benchmark
'org_babel_R_eoe'
############## Bedingte und undbedingte Entropie in normaler Reihenfolge

modell[[1]] = glm(reformulate('1', names(komusmult[1])), data = komusmult, family = "binomial"(link=logit))

for (i in 2:items) {
    if (i %in% multifragen) {
        modell[[i]] = polr(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult)
    } else {
        modell[[i]] = glm(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult, family = "binomial"(link=logit))
    }
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = FUN.Chances(fitting)
#chances[-multifragen] = mclapply(fitting[-multifragen], predict, type="response")
#chances[multifragen] = mclapply(fitting[multifragen], predict, type="probs")

Entropietemp = fitting

Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC)
Entropietemp[-multifragen] =lapply(chances[-multifragen], FUN.Entropie)
Entropietemp = simplify2array(Entropietemp)

### Without relations ###
modell = lapply(modell, update, ~ 1)
chances2 = modell
chances2[-multifragen] = mclapply(modell[-multifragen], predict, type="response")
chances2[multifragen] = mclapply(modell[multifragen], predict, type="probs")
Entropietemp2 = modell
Entropietemp2[multifragen] = lapply(chances2[multifragen], FUN.EntropieMC)
Entropietemp2[-multifragen] =lapply(chances2[-multifragen], FUN.Entropie)
Entropietemp2 = simplify2array(Entropietemp2)
#c(sapply(chances[multifragen], FUN.EntropieMC), sapply(fitting[-multifragen], predict, type="response"))


SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$bedunsort = c(0,SumSDtemp)


EEE$bedunsort = c(0,colMeans(Entropietemp))
EEE$unbedunsort = c(0,colMeans(Entropietemp2))
EEE$unbedsort = c(0,sort(colMeans(Entropietemp2), decreasing =TRUE))
'org_babel_R_eoe'
require(MASS)
library(multicore)
library(foreach)
library(doMC)
registerDoMC(8)

calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
komusmult = data.frame(read.table("data/komus.csv",header=TRUE, sep=','))
multifragen = array(which(sapply(komusmult, max) > 1))
komusmult[multifragen] = lapply(komusmult[multifragen],factor)

FUN.EntropieMC = function(x) {return(rowSums(-x*log(x,2)))}
FUN.Entropie = function(x) {return(-x*log(x, 2)-(1-x)*log(1-x, 2))}
FUN.Chances = function(x) {
x[-multifragen] = lapply(x[-multifragen], predict, type="response")
x[multifragen] = lapply(x[multifragen], predict, type="probs")
return(x)
}


Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()
############
#items = length(komus)
persons = length(komus[,1])
items = 50
#persons = 50
############

EEE = data.frame(matrix(ncol = 1, nrow = items+1))
SumSD = data.frame(matrix(ncol = 1, nrow = items+1))
RestEntropie = data.frame(matrix(ncol = 1, nrow = items+1))
RestEntropieSD = data.frame(matrix(ncol = 1, nrow = items+1))
names(EEE) = 'kill'
names(SumSD) = 'kill'
names(RestEntropie) = 'kill'
names(RestEntropieSD) = 'kill'
'org_babel_R_eoe'
############## Bedingte und undbedingte Entropie in normaler Reihenfolge

modell[[1]] = glm(reformulate('1', names(komusmult[1])), data = komusmult, family = "binomial"(link=logit))

for (i in 2:items) {
    if (i %in% multifragen) {
        modell[[i]] = polr(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult)
    } else {
        modell[[i]] = glm(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult, family = "binomial"(link=logit))
    }
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = FUN.Chances(fitting)
#chances[-multifragen] = mclapply(fitting[-multifragen], predict, type="response")
#chances[multifragen] = mclapply(fitting[multifragen], predict, type="probs")

Entropietemp = fitting

Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC)
Entropietemp[-multifragen] =lapply(chances[-multifragen], FUN.Entropie)
Entropietemp = simplify2array(Entropietemp)

### Without relations ###
modell = lapply(modell, update, ~ 1)
chances2 = modell
chances2[-multifragen] = mclapply(modell[-multifragen], predict, type="response")
chances2[multifragen] = mclapply(modell[multifragen], predict, type="probs")
Entropietemp2 = modell
Entropietemp2[multifragen] = lapply(chances2[multifragen], FUN.EntropieMC)
Entropietemp2[-multifragen] =lapply(chances2[-multifragen], FUN.Entropie)
Entropietemp2 = simplify2array(Entropietemp2)
#c(sapply(chances[multifragen], FUN.EntropieMC), sapply(fitting[-multifragen], predict, type="response"))


SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$bedunsort = c(0,SumSDtemp)


EEE$bedunsort = c(0,colMeans(Entropietemp))
EEE$unbedunsort = c(0,colMeans(Entropietemp2))
EEE$unbedsort = c(0,sort(colMeans(Entropietemp2), decreasing =TRUE))
'org_babel_R_eoe'
################# Schlussberechnungen

if (names(EEE[1]) == 'kill') {
    EEE = EEE[-1]
}
if (names(SumSD[1]) == 'kill') {
    SumSD = SumSD[-1]
}
if (names(RestEntropie[1]) == 'kill') {
    RestEntropie = RestEntropie[-1]
    RestEntropieSD = RestEntropieSD[-1]
}

for (i in 1:length(EEE[1,])) {
    for (j in 1:length(EEE[,1])) {
        summe[j,i] = sum(EEE[1:j,i])
    }
}

RestEntropie[1,] = sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2))

names(summe) = names(EEE)

if (exists("benchmark")) {
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else {
    benchmark = (proc.time() - calculationtime)[3]
}


benchmark
'org_babel_R_eoe'
png(filename="/images/entropie2.png")

farbe = NULL
farbeSD = NULL
for (j in 1:(length(summe[1,]))) {
    r = runif(1,0.1,0.9)
    g = runif(1,0.1,0.9)
    b = runif(1,0.1,0.9)
    farbe[j] = rgb(r^1.2, g^1.2, b^1.2)
    farbeSD[j] = rgb(sqrt(r), sqrt(g), sqrt(b))
}

plot(0:(length(komusmult)), type="l", col=rgb(0,0,0), ann=F)
for (i in 1:(length(summe[1,]))) {
    lines(summe[,i], col=farbe[i])
    if (dim(SumSD[names(SumSD) == names(summe[i])])[2] != 0) {
        lines(summe[,i]+SumSD[names(summe[i])],lty = 4, col=farbeSD[i])
        lines(summe[,i]-SumSD[names(summe[i])],lty = 4, col=farbeSD[i])
    }
    if (dim(RestEntropie[names(RestEntropie) == names(summe[i])])[2] != 0) {
        lines(RestEntropie[names(summe[i])], col=farbe[i])
        lines(RestEntropie[names(summe[i])]+RestEntropieSD[names(summe[i])],lty = 4, col=farbeSD[i])
        lines(RestEntropie[names(summe[i])]-RestEntropieSD[names(summe[i])],lty = 4, col=farbeSD[i])
    }
}

title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(length(komus)/4, length(komus), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1);

dev.off()
'org_babel_R_eoe'
require(MASS)
library(multicore)
library(foreach)
library(doMC)
registerDoMC(8)

calculationtime <- proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE) 
komusmult = data.frame(read.table("data/komus.csv",header=TRUE, sep=','))
multifragen = array(which(sapply(komusmult, max) > 1))
komusmult[multifragen] = lapply(komusmult[multifragen],factor)

FUN.EntropieMC = function(x) {return(rowSums(-x*log(x,2)))}
FUN.Entropie = function(x) {return(-x*log(x, 2)-(1-x)*log(1-x, 2))}
FUN.Chances = function(x) {
x[-multifragen] = lapply(x[-multifragen], predict, type="response")
x[multifragen] = lapply(x[multifragen], predict, type="probs")
return(x)
}
FUN.Entropietemp = function(x) {
x[multifragen] = lapply(x[multifragen], FUN.EntropieMC)
x[-multifragen] =lapply(x[-multifragen], FUN.Entropie)
x = simplify2array(x)
return(x)
}

Entropie = NULL
chances = NULL
fitting = NULL
modell = NULL
summe = data.frame()
############
#items = length(komus)
persons = length(komus[,1])
items = 50
#persons = 50
############

EEE = data.frame(matrix(ncol = 1, nrow = items+1))
SumSD = data.frame(matrix(ncol = 1, nrow = items+1))
RestEntropie = data.frame(matrix(ncol = 1, nrow = items+1))
RestEntropieSD = data.frame(matrix(ncol = 1, nrow = items+1))
names(EEE) = 'kill'
names(SumSD) = 'kill'
names(RestEntropie) = 'kill'
names(RestEntropieSD) = 'kill'
'org_babel_R_eoe'
############## Bedingte und undbedingte Entropie in normaler Reihenfolge

modell[[1]] = glm(reformulate('1', names(komusmult[1])), data = komusmult, family = "binomial"(link=logit))

for (i in 2:items) {
    if (i %in% multifragen) {
        modell[[i]] = polr(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult)
    } else {
        modell[[i]] = glm(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult, family = "binomial"(link=logit))
    }
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = FUN.Chances(fitting)
#chances[-multifragen] = mclapply(fitting[-multifragen], predict, type="response")
#chances[multifragen] = mclapply(fitting[multifragen], predict, type="probs")

#Entropietemp = fitting
Entropietemp = FUN.Entropietemp(chances)
#Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC)
#Entropietemp[-multifragen] =lapply(chances[-multifragen], FUN.Entropie)
#Entropietemp = simplify2array(Entropietemp)

### Without relations ###
fitting = lapply(fitting, update, ~ 1)
chances2 = FUN.Chances(fitting)
#chances2[-multifragen] = mclapply(modell[-multifragen], predict, type="response")
#chances2[multifragen] = mclapply(modell[multifragen], predict, type="probs")
Entropietemp2 = modell
Entropietemp2[multifragen] = lapply(chances2[multifragen], FUN.EntropieMC)
Entropietemp2[-multifragen] =lapply(chances2[-multifragen], FUN.Entropie)
Entropietemp2 = simplify2array(Entropietemp2)
#c(sapply(chances[multifragen], FUN.EntropieMC), sapply(fitting[-multifragen], predict, type="response"))


SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$bedunsort = c(0,SumSDtemp)


EEE$bedunsort = c(0,colMeans(Entropietemp))
EEE$unbedunsort = c(0,colMeans(Entropietemp2))
EEE$unbedsort = c(0,sort(colMeans(Entropietemp2), decreasing =TRUE))
'org_babel_R_eoe'
############## Bedingte und undbedingte Entropie in normaler Reihenfolge

modell[[1]] = glm(reformulate('1', names(komusmult[1])), data = komusmult, family = "binomial"(link=logit))

for (i in 2:items) {
    if (i %in% multifragen) {
        modell[[i]] = polr(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult)
    } else {
        modell[[i]] = glm(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult, family = "binomial"(link=logit))
    }
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = FUN.Chances(fitting)
#chances[-multifragen] = mclapply(fitting[-multifragen], predict, type="response")
#chances[multifragen] = mclapply(fitting[multifragen], predict, type="probs")

#Entropietemp = fitting
Entropietemp = FUN.Entropietemp(chances)
#Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC)
#Entropietemp[-multifragen] =lapply(chances[-multifragen], FUN.Entropie)
#Entropietemp = simplify2array(Entropietemp)

### Without relations ###
fitting = lapply(fitting, update, ~ 1)
chances2 = FUN.Chances(fitting)
#chances2[-multifragen] = mclapply(modell[-multifragen], predict, type="response")
#chances2[multifragen] = mclapply(modell[multifragen], predict, type="probs")
#Entropietemp2 = modell
Entropietemp2 = FUN.Entropietemp(chances2)
#Entropietemp2[multifragen] = lapply(chances2[multifragen], FUN.EntropieMC)
#Entropietemp2[-multifragen] =lapply(chances2[-multifragen], FUN.Entropie)
#Entropietemp2 = simplify2array(Entropietemp2)
#c(sapply(chances[multifragen], FUN.EntropieMC), sapply(fitting[-multifragen], predict, type="response"))


SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$bedunsort = c(0,SumSDtemp)


EEE$bedunsort = c(0,colMeans(Entropietemp))
EEE$unbedunsort = c(0,colMeans(Entropietemp2))
EEE$unbedsort = c(0,sort(colMeans(Entropietemp2), decreasing =TRUE))
'org_babel_R_eoe'
############## Bedingte und undbedingte Entropie in normaler Reihenfolge
modell = NULL

if (1 %in% multifragen) {
    modell[[1]] = polr(reformulate('1', names(komusmult[1])), data = komusmult)
} else {
    modell[[1]] = glm(reformulate('1', names(komusmult[1])), data = komusmult, family = "binomial"(link=logit))
}

for (i in 2:items) {
    if (i %in% multifragen) {
        modell[[i]] = polr(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult)
    } else {
        modell[[i]] = glm(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult, family = "binomial"(link=logit))
    }
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = FUN.Chances(fitting)
#chances[-multifragen] = mclapply(fitting[-multifragen], predict, type="response")
#chances[multifragen] = mclapply(fitting[multifragen], predict, type="probs")

#Entropietemp = fitting
Entropietemp = FUN.Entropietemp(chances)
#Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC)
#Entropietemp[-multifragen] =lapply(chances[-multifragen], FUN.Entropie)
#Entropietemp = simplify2array(Entropietemp)

### Without relations ###
fitting = lapply(fitting, update, ~ 1)
chances2 = FUN.Chances(fitting)
#chances2[-multifragen] = mclapply(modell[-multifragen], predict, type="response")
#chances2[multifragen] = mclapply(modell[multifragen], predict, type="probs")
#Entropietemp2 = modell
Entropietemp2 = FUN.Entropietemp(chances2)
#Entropietemp2[multifragen] = lapply(chances2[multifragen], FUN.EntropieMC)
#Entropietemp2[-multifragen] =lapply(chances2[-multifragen], FUN.Entropie)
#Entropietemp2 = simplify2array(Entropietemp2)
#c(sapply(chances[multifragen], FUN.EntropieMC), sapply(fitting[-multifragen], predict, type="response"))


SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$bedunsort = c(0,SumSDtemp)


EEE$bedunsort = c(0,colMeans(Entropietemp))
EEE$unbedunsort = c(0,colMeans(Entropietemp2))
EEE$unbedsort = c(0,sort(colMeans(Entropietemp2), decreasing =TRUE))
'org_babel_R_eoe'
############## Bedingte und undbedingte Entropie in normaler Reihenfolge
modell = NULL

if (1 %in% multifragen) {
    modell[[1]] = polr(reformulate('1', names(komusmult[1])), data = komusmult)
} else {
    modell[[1]] = glm(reformulate('1', names(komusmult[1])), data = komusmult, family = "binomial"(link=logit))
}

for (i in 2:items) {
    if (i %in% multifragen) {
        modell[[i]] = polr(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult)
    } else {
        modell[[i]] = glm(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult, family = "binomial"(link=logit))
    }
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = FUN.Chances(fitting)
#chances[-multifragen] = mclapply(fitting[-multifragen], predict, type="response")
#chances[multifragen] = mclapply(fitting[multifragen], predict, type="probs")

#Entropietemp = fitting
Entropietemp = FUN.Entropietemp(chances)
#Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC)
#Entropietemp[-multifragen] =lapply(chances[-multifragen], FUN.Entropie)
#Entropietemp = simplify2array(Entropietemp)

### Without relations ###
fitting = lapply(fitting, update, ~ 1)
chances2 = FUN.Chances(fitting)
#chances2[-multifragen] = mclapply(modell[-multifragen], predict, type="response")
#chances2[multifragen] = mclapply(modell[multifragen], predict, type="probs")
#Entropietemp2 = modell
Entropietemp2 = FUN.Entropietemp(chances2)
#Entropietemp2[multifragen] = lapply(chances2[multifragen], FUN.EntropieMC)
#Entropietemp2[-multifragen] =lapply(chances2[-multifragen], FUN.Entropie)
#Entropietemp2 = simplify2array(Entropietemp2)
#c(sapply(chances[multifragen], FUN.EntropieMC), sapply(fitting[-multifragen], predict, type="response"))


SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$bedunsort = c(0,SumSDtemp)


EEE$bedunsort = c(0,colMeans(Entropietemp))
EEE$unbedunsort = c(0,colMeans(Entropietemp2))
EEE$unbedsort = c(0,sort(colMeans(Entropietemp2), decreasing =TRUE))

Entropietemp2
'org_babel_R_eoe'
############## Bedingte und undbedingte Entropie in normaler Reihenfolge
modell = NULL

if (1 %in% multifragen) {
    modell[[1]] = polr(reformulate('1', names(komusmult[1])), data = komusmult)
} else {
    modell[[1]] = glm(reformulate('1', names(komusmult[1])), data = komusmult, family = "binomial"(link=logit))
}

for (i in 2:items) {
    if (i %in% multifragen) {
        modell[[i]] = polr(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult)
    } else {
        modell[[i]] = glm(reformulate(names(komusmult[1:i-1]), names(komusmult[i])), data = komusmult, family = "binomial"(link=logit))
    }
}
fitting = modell
#fitting = mclapply(fitting, step, trace = 0)
#fitting = mclapply(fitting, step, ~.^2, trace = 0)
chances = FUN.Chances(fitting)
#chances[-multifragen] = mclapply(fitting[-multifragen], predict, type="response")
#chances[multifragen] = mclapply(fitting[multifragen], predict, type="probs")

#Entropietemp = fitting
Entropietemp = FUN.Entropietemp(chances)
#Entropietemp[multifragen] = lapply(chances[multifragen], FUN.EntropieMC)
#Entropietemp[-multifragen] =lapply(chances[-multifragen], FUN.Entropie)
#Entropietemp = simplify2array(Entropietemp)

### Without relations ###
fitting = lapply(fitting, update, ~ 1)
chances2 = FUN.Chances(fitting)
#chances2[-multifragen] = mclapply(modell[-multifragen], predict, type="response")
#chances2[multifragen] = mclapply(modell[multifragen], predict, type="probs")
#Entropietemp2 = modell
Entropietemp2 = FUN.Entropietemp(chances2)
#Entropietemp2[multifragen] = lapply(chances2[multifragen], FUN.EntropieMC)
#Entropietemp2[-multifragen] =lapply(chances2[-multifragen], FUN.Entropie)
#Entropietemp2 = simplify2array(Entropietemp2)
#c(sapply(chances[multifragen], FUN.EntropieMC), sapply(fitting[-multifragen], predict, type="response"))


SumSDtemp = sd(Entropietemp[,1])
for (i in 2:length(Entropietemp[1,])) {
SumSDtemp[i] = sd(rowSums(Entropietemp[,1:i]))
}

SumSD$bedunsort = c(0,SumSDtemp)


EEE$bedunsort = c(0,colMeans(Entropietemp))
EEE$unbedunsort = c(0,colMeans(Entropietemp2))
EEE$unbedsort = c(0,sort(colMeans(Entropietemp2), decreasing =TRUE))

names(Entropietemp2) = names(komusmult)
Entropietemp2
'org_babel_R_eoe'
