#+BEGIN_COMMENT
---
layout: post
title: Adaptives Testen
father: Wissenschaft
---
#+END_COMMENT
Beim adaptiven Testen werden die Möglichkeiten einer computerbasierten Testung in erweitertem Maße ausgenutzt.
Es wird innerhalb der Testung auf Grund der bereits beantworteten Fragen auf den Fähigkeitsgrad des Probanden geschätzt, um ihm als nächstes eine Frage zu geben, die diesen reflektiert.

#+BEGIN_SRC ditaa :file /images/adaptiveditaa.png :exports results
+---------+   +--------+   +---------------+
|  Item-  |-->| Modell |-->|   Schätzung   |
| antwort |   +--------+   | nächstes Item |
+---------+                +-------+-------+
    ^                              |
    |                              |
    +------------------------------+
#+END_SRC

* Kriterien
Wie genau die Frage ausgewählt wird hängt vornehmlich von den Zielen der Testung und den Nebenwirkungen, die man ggf. vermeiden möchte, ab.
So wäre eine Frage, die der Proband mit einer Chance von 50% lösen kann ideal im Sinne eines Informationsgewinnes über den Probanden, da die Entropie maximal ist.

Entropie stellt nicht nur Chaos, sondern auch Informationsdichte nach Shannon dar (vgl. [[http://de.wikipedia.org/wiki/Entropie_%28Informationstheorie%29][Wikipedia]]).
Die folgende Formel ergiebt die Entropie eines Ereignisses. Hierbei ist $n$ die Anzahl der Möglichkeiten und $p_i$ die jeweiligen Wahrscheinlichkeiten dieser (sich ausschließender) Möglichkeiten.
$$ H = - \sum_{i=1}^n p_i \cdot \log_2{p_i} $$

Betrachten wir ein binäres System, also nur Fragen die entweder vollständig falsch oder vollständig richtig beantwortet werden können, so haben wir $n = 2$ und $p_2 = 1 - p_1$.
$$ H_2 = - p \cdot \log_2{p} - (1 - p) \cdot \log_2(1 - p) $$

Hieraus ergiebt sich, dass der Informationsgewinn bei $p = .5$ (im binären) maximal ist, da die Funktion symmetrisch ist und bei $p = 0$ auf beiden Seiten $0$ ergibt.
$$ H_{max} = - 0.5 \cdot \log_2{0.5} - 0.5 \cdot \log_2{0.5} = 1 \mathrm{bit} $$

Hierbei ist $bit$ die übliche Einheit des Informationsgehaltes, auf Grund des $\log_2$. Es kann also ein Informationsgehalt von 8 bit mit Hilfe eines bytes dargestellt werden, sprich mit 8 Nullen oder Einsen (z.B. 10101010).

#+BEGIN_SRC R :results output graphics :file /images/entropie.png :exports results
x = (0:100)/100
y = -x*log(x,2)-(1-x)*log(1-x,2)
plot(x,y,type="l",xlab=expression(Lösungswahrscheinlichkeit),ylab=expression("Entropie in bit"),  main="Entropieverteilung")
#+END_SRC

#+RESULTS:
[[file:/images/entropie.png]]

Mit der Formel für tatsächliche und für maximale Entropie kann die Redundanz ausgerechnet werden, welche in einer Testkonstruktion als Indikator für das Potential der Verbesserung durch ein adaptives Testverfahren benutzt werden kann.
$$ R = H_{max} - H $$

Somit kann im binären ein Test im idealfall um $R$ Fragen verkleinert werden, ohne an Informationen einzubüßen.
Befinden sich im Test auch Fragen, die nicht binär sind, so verändert sich die Situation ein wenig.
Die Entropie wird stets maximal bei gleichen Wahrscheinlichkeiten.
Gibt es nun bei einer Frage z.B. 0, 1, 2 oder 3 Punkte gibt es eine maximale Entropie von $H_{max} = - \log_2{0.25} = 2 \mathrm{bit}$. Somit kann man einen Test auch um $R/2$ solcher Fragen ohne Informationsverlust verkleinern.

** Informationsgehalt in KoMus
Im August diesen Jahres habe ich mit Teilen des KoMus-Testes für musikalische Kompetenz eine empirische Studie durchgeführt.
Der KoMus-Test liegt in einem nicht adaptiven Format vor.

Interessant ist nun, die Überlegung, wieviel der Test von einer Überführung in einen adaptiven Test profitieren würde.

*** Durchschnittlicher Schüler
Der Simplizität halber können wir annehmen, dass ein Schüler genau die durchschnittlichen Lösungswahrscheinlichkeiten für ein Item aufweist.
So muss man nur die Entropie mit den klassischen Itemschwierigkeiten der Items berechnen:
$$ H = \sum_{i=1}^n(- P_i \cdot \log_2{P_i} - (1 - P_i) \cdot \log_2(1 - P_i)) $$

Hierbei ist $P_i$ die klassische Itemschwierigkeit des Items $i$ und $n$ die Anzahl der Items.
Ferner nimmt diese Formel nur dichotome Items an.

*** Vierdimensional
Die Entropie ist jedoch eigentlich noch niedriger, wenn man die Schwierigkeiten adaptiv berechnet. 
Es handelt sich aber immernoch um einen nicht adaptiven Test mit fester Reihenfolge. Es wird nur eine spezialform der Entropie, die bedingte Entropie, benutzt (vgl. [[http://de.wikipedia.org/wiki/Bedingte_Entropie][Wikipedia]]).

Um die bedingte Lösungschance und somit auch die bedingte Entropie zu berechnen, werden alle Items der selben Dimension einer logistisch binären Regression verwendet um die individuell Itemschwierigkeit eines Items der gleichen Dimension zu berechnen.
$$ H = \sum_{D=1}^4(\sum_{i=1}^{n(D)}(- R \cdot \log_2{R}) - (1 - R) \cdot \log_2(1- R))$$
$$ R = Reg_2(P_{ivD}|\sum_{m=1}^{i(D)-1}P_{vmD}) $$

Hierbei ist $Reg_2(a|b)$ die binärlogistische Regression mit der AV $a$ und den UV $b$.

*** n-Dimensional
Das obige Modell nimmt jedoch an, dass die einzelnen Dimensionen nicht korrelieren und somit Itemantworten einer Dimension keine Information (also Entropiesenkung) über andere Dimensionen zulassen.

Dies ist aber eine nicht notwendige Einschränkung, die die Berechnung nicht nur weniger effektiv, sondern auch komplizierter macht.

Berücksichtigen wir unabhängig von der Dimensionszugehörigkeit einfach alle bereits beantworteten Items, die einen signifikanten Einfluss auf die Frage haben, haben wir im Endeffekt ein n-dimensionales Modell, wobei $n$ die Anzahl der Fragen ist.
$$ H = \sum_{i=1}^n(- R \cdot \log_2{R} - (1 - R) \cdot \log_2(1 - R)) $$
$$ R = Reg_2(P_{iv}|\sum_{m=1}^{i-1}P_{vm}) $$

**** Probleme
Mögliche Probleme dieser Methode sind fehlende Datensätze, da die binärlogistische Regression normalerweise alle Fälle ausschließt, die auch nur bei einem der UV keinen Wert hat.
Durch den maßgeschneiderten Testweg ist es bei einem Itempool, der nicht komplett erschöpft wird, unmöglich diese Regression so durchzuführen.
Dementsprechend müssen andere Methoden gewählt werden, um mit fehlenden Daten umzugehen.

Eine Möglichkeit wäre, nicht vorhandene Antworten in den Datensätzen zu simulieren.
Diese Simulation würde von den Items die am sichersten geschätzt werden können zu den Items, die schwer geschätzt werden können stattfinden.

Der Grund hierfür liegt daran, dass bei einer sehr sicheren Schätzung der Entropiegehalt sich nur wenig ändert, aber es gleich viel mehr Personen gibt, die seriös für schwerere Schätzungen verwendet werden können, was diese Schätzungen erleichtert.

Die Simulation sollte nach jeder Testung durchgeführt werden, um die Simulation mehr und mehr zu verbessern.
Das dieses Verfahren direkt einen Nutzen erbringt, sollte daran sichtbar sein, dass die Lösungen der alten Datensätze immer besser retrospektiv vorhergesagt werden können und somit davon außgegangen werden kann, dass auch bei aktuellen Testungen die Schätzungen besser sind und somit effektiver gemessen werden kann.

* Umsetzung
Die Umsetzung wurde mit R bewerkstelligt. Hier traten auch schnell Probleme auf.
So wurde die Rechenzeit bei etwas komplizierteren Modellen sehr lang, was natürlich auch an meinem Computer liegt.
Nichts desto trotz ergaben sich Situationen, in denen der Computer 5 Tage lang rechnen hätte müssen.

In anderen Situationen wurde das komplette RAM des Computers aufgezehrt usw.

** Programmierung

*** Initialisierung

Für alle nachfolgenden Berechnungen habe ich immer dieses Skript benutzt, um grundlegende Dinge, wie Funktionen, die an vielen Stellen benötigt werden, die Daten usw. bereitgestellt werden.
Ferner werden, wo möglich, Berechnungen mit dieser Initialisierung parallelisiert.

#+NAME: statistic
#+BEGIN_SRC R :session stat :exports code :results output :noweb yes
require(MASS)
library(foreach)
library(doMC)
# number of cores to use
registerDoMC(4)

calculationtime = proc.time()
komus = read.table("data/data_komus_bin2.dat",header=TRUE)
test = data.frame(read.table("data/komus.csv",header=TRUE, sep=','))
pcitems = array(which(sapply(test, max) > 1))
pcitems.temp = pcitems
test[pcitems] = lapply(test[pcitems],factor)

# functions
FUN.infoMC = function(x)
{
    return(rowSums(-x*log(x+0.0000000001, 2)))
}

FUN.infoMC.IND = function(x)
{
    return(sum(-x*log(x+0.0000000001, 2)))
}

FUN.info = function(x)
{
    return(-x*log(x+0.0000000001, 2)-(1-x)*log(1-x+0.0000000001, 2))
}

FUN.Odds = function(x)
{
    if (length(pcitems.temp) > 0)
    {
        x[-pcitems.temp] = lapply(x[-pcitems.temp], predict, type="response")
        x[pcitems.temp] = lapply(x[pcitems.temp], predict, type="probs")
    } else
    {
        x = lapply(x, predict, type="response")
    }
    return(x)
}

FUN.Odds.IND = function(x,y)
{
    x[-pcitems.temp] = lapply(x[-pcitems.temp], predict, data = test[y,], type="response")
    x[pcitems.temp] = lapply(x[pcitems.temp], predict, data = test[y,], type="probs")
    return(x)
}

FUN.info.temp = function(x)
{
    if (length(pcitems.temp) > 0)
    {
        x[pcitems.temp] = lapply(x[pcitems.temp], FUN.infoMC)
        x[-pcitems.temp] =lapply(x[-pcitems.temp], FUN.info)
    } else   
    {
        x =lapply(x, FUN.info)
    }
    x = simplify2array(x)
    return(x)
}

FUN.info.temp.IND = function(x)
{
    if (length(pcitems.temp) > 0)
    {
        x[pcitems.temp] = lapply(x[pcitems.temp], FUN.infoMC.IND)
        x[-pcitems.temp] =lapply(x[-pcitems.temp], FUN.info)
    } else
    {
        x =lapply(x, FUN.info)
    }
    x = simplify2array(x)
    return(x)
}

FUN.EntroMC = function(funpcitems.temp, fundata, funmod)
{
    if (length(funpcitems.temp) == 1)
    {
        odds = lapply(funmod, predict, fundata, type="response")
        info.temp = odds
        info.temp = lapply(odds, FUN.info)
        info.temp = simplify2array(info.temp)
    } else
    {
        funpcitems.temp = funpcitems.temp[2:length(funpcitems.temp)]
        odds = funmod
        odds[-funpcitems.temp] = lapply(funmod[-funpcitems.temp], predict, fundata, type="response")
        odds[funpcitems.temp] = lapply(funmod[funpcitems.temp], predict, fundata, type="probs")
        info.temp = odds
        info.temp[funpcitems.temp] = lapply(odds[funpcitems.temp], FUN.infoMC.IND)
        info.temp[-funpcitems.temp] = lapply(odds[-funpcitems.temp], FUN.info)
        info.temp = simplify2array(info.temp)
    }
    return(info.temp)
}

odds = NULL
fit = NULL
modell = NULL
summe = data.frame()

# number of items and persons to consider in this calculation
items = length(test)
persons = length(test[,1])

info = NULL
info.rest = data.frame(matrix(ncol = 1, nrow = items+1))
info.rest.SD = data.frame(matrix(ncol = 1, nrow = items+1))
names(info.rest) = 'kill'
names(info.rest.SD) = 'kill'

entropie = data.frame(matrix(ncol = 1, nrow = items+1))
entropie.SD = data.frame(matrix(ncol = 1, nrow = items+1))
names(entropie) = 'kill'
names(entropie.SD) = 'kill'
#+END_SRC

#+RESULTS: statistic
: Lade nötiges Paket: MASS
: foreach: simple, scalable parallel programming from Revolution Analytics
: Use Revolution R for scalability, fault tolerance and more.
: http://www.revolutionanalytics.com
: Lade nötiges Paket: iterators
: Lade nötiges Paket: parallel

*** Nichtadaptiv
**** Unbedingte und bedingte info in normaler Reihenfolge
Dieser verhältnismäßig simple Code berechnet die info über die klassische Itemschwierigkeit und die info über die durch binär-logistische Regressionen vorhergesagte Itemschwierigkeit in der ursprünglichen Reihenfolge.
Zudem wird bei zweiter Berechnung noch angegeben, wie viel entropie.rest nach jeder Antwort noch zu erwarten ist.
#+NAME: statistic1
#+BEGIN_SRC R :exports code :results output :noweb yes
modell = NULL
pcitems.temp = pcitems.temp[pcitems.temp <= items]

if (1 %in% pcitems.temp)
{
    modell[[1]] = polr(reformulate('1', names(test[1])), data = test)
} else
{
    modell[[1]] = glm(reformulate('1', names(test[1])), data = test, family = "binomial"(link=logit))
}

for (i in 2:items)
{
    if (i %in% pcitems.temp)
    {
        modell[[i]] = polr(reformulate(names(test[1:i-1]), names(test[i])), data = test)
    } else
    {
        modell[[i]] = glm(reformulate(names(test[1:i-1]), names(test[i])), data = test, family = "binomial"(link=logit))
    }
}

fit = modell
<<fit>>
odds = FUN.Odds(fit)
info.temp = FUN.info.temp(odds)

### Without relations ###
fit = lapply(fit, update, ~ 1)
odds2 = FUN.Odds(fit)
info.temp2 = FUN.info.temp(odds2)
pcitems.temp = pcitems
query = NULL
rest.temp = NULL

for (i in 1:items)
{
    info.temp3 = NULL
    fit3 = NULL
    
    if (i == length(test))
    {
        rest.temp[[i]] = rest.temp[[1]]*0
    } else
    {
        query = 1:i
        pcitems.temp = which(names(test[-query]) %in% names(test[pcitems]))
        
        for (j in 1:length(test[-query]))
        {
            if (j %in% pcitems.temp)
            {
                fit3[[j]] = polr(reformulate(names(test[query]), names(test[-query][j])), data = test)
            } else
            {
                fit3[[j]] = glm(reformulate(names(test[query]), names(test[-query][j])), data = test, family = "binomial"(link=logit))
            }
        }
        
        <<fit>>
        odds3 = FUN.Odds(fit3)
        info.temp3 = FUN.info.temp(odds3)
        rest.temp[[i]] = rowSums(info.temp3)
    }
}

rest.temp = simplify2array(rest.temp)
info.rest$bedunsort = c(0,colMeans(rest.temp))
info.rest.SD$bedunsort = c(0,apply(rest.temp, 2, sd))
entropie.SD.temp = sd(info.temp[,1])

for (i in 2:length(info.temp[1,]))
{
    entropie.SD.temp[i] = sd(rowSums(info.temp[,1:i]))
}

entropie.SD$bedunsort = c(0,entropie.SD.temp)
entropie$bedunsort = c(0,colMeans(info.temp))
entropie$unbedunsort = c(0,colMeans(info.temp2))
entropie$unbedsort = c(0,sort(colMeans(info.temp2), decreasing =TRUE))
info.temp2 = data.frame(info.temp2)
names(info.temp2) = names(test[1:length(info.temp2)])
entropie
info.rest
#+END_SRC

**** Bedingte, sortierte info
Hier werden die Items schlicht nach dem durchschnittlichen infogehalt sortiert, bevor die bedingte info mit Regressionen berechnet wird.
Dies verbessert die resultierende Kurve schon um einiges, der infogewinn ist so tendenziell am Anfang weit höher als am Ende, trotz dass gleich viel info innerhalb des kompletten Durchlaufes ermittelt wurde.
#+NAME: statistic2
#+BEGIN_SRC R :exports code :results output :noweb yes
modell = NULL
odds = NULL
fit = NULL

############## sortierte Reihenfolge
for (i in 1:items)
{
    if (i %in% pcitems.temp)
    {
        modell[[i]] = polr(reformulate('1', names(test[i])), data = test)
    } else
    {
        modell[[i]] = glm(reformulate('1', names(test[i])), data = test, family = "binomial"(link=logit))
    }
}

odds = FUN.Odds(modell)
info.temp = FUN.info.temp(odds)
info.temp = data.frame(info.temp)
names(info.temp) = names(test[1:length(info.temp)])
komus2 = test[c(names(sort(colMeans(info.temp), decreasing=TRUE)))]
#########

names(sort(colMeans(info.temp), decreasing=TRUE))
pcitems.temp.alt = pcitems.temp
pcitems.temp.alt
pcitems.temp = which(names(komus2) %in% names(test[pcitems.temp.alt]))
modell = NULL
fit = NULL
odds = NULL

if (1 %in% pcitems.temp)
{
    modell[[1]] = polr(reformulate('1', names(komus2[1])), data = komus2)
} else
{
    modell[[1]] = glm(reformulate('1', names(komus2[1])), data = komus2, family = "binomial"(link=logit))
}

for (i in 2:items)
{
    if (i %in% pcitems.temp)
    {
        modell[[i]] = polr(reformulate(names(komus2[1:i-1]), names(komus2[i])), data = komus2)
    } else {
        modell[[i]] = glm(reformulate(names(komus2[1:i-1]), names(komus2[i])), data = komus2, family = "binomial"(link=logit))
    }
}

fit = modell
<<fit>>
odds = FUN.Odds(fit)
#odds[-pcitems.temp] = lapply(fit[-pcitems.temp], predict, type="response")
#odds[pcitems.temp] = lapply(fit[pcitems.temp], predict, type="probs")

#info.temp = fit
info.temp = FUN.info.temp(odds)
#info.temp[pcitems.temp] = lapply(odds[pcitems.temp], FUN.infoMC)
#info.temp[-pcitems.temp] =lapply(odds[-pcitems.temp], FUN.info)
#info.temp = simplify2array(info.temp)

entropie.SD.temp = sd(info.temp[,1])

for (i in 2:length(info.temp[1,]))
{
    entropie.SD.temp[i] = sd(rowSums(info.temp[,1:i]))
}

entropie.SD$sortbed = c(0,entropie.SD.temp)
entropie$sortbed = c(0,colMeans(info.temp))
pcitems.temp = pcitems.temp.alt
#+END_SRC

**** Durchschnittlich bedingtsortierte info
Dieses Verfahren ist bereits weit rechenintensiver, es wird nacheinander das Item ausgewählt, welches durchschnittlich die info am meisten senkt.
Es wird also nach der Erfassung eines Items dieses miteinbezogen für kommende Regressionen.
Insgesamt ist dies aber noch nicht individualisiert und dementsprechen nicht adaptiv.
#+NAME: statistic3
#+BEGIN_SRC R :exports code :results output :noweb yes
query = NULL
modell = NULL
rest.temp = NULL
pcitems = pcitems.temp
############## sortierte Reihenfolge
for (i in 1:length(test))
{
    if (i %in% pcitems.temp)
    {
        fit[[i]] = polr(reformulate('1', names(test[i])), data = test)
    } else
    {
        fit[[i]] = glm(reformulate('1', names(test[i])), data = test, family = "binomial"(link=logit))
    }
}
odds = FUN.Odds(fit)
info.temp = FUN.info.temp(odds)
query = which(names(test[which(colMeans(info.temp) == max(colMeans(info.temp)))[1]]) == names(test))[1]
query
modell[[1]] = fit[[query]]

for (i in 2:items) {
    info.temp = NULL
    fit = NULL
    pcitems.temp = which(names(test[-query]) %in% names(test[pcitems]))
    
    for (j in 1:length(test[-query]))
    {
        if (j %in% pcitems.temp)
        {
            fit[[j]] = polr(reformulate(names(test[query]), names(test[-query][j])), data = test)
        } else
        {
            fit[[j]] = glm(reformulate(names(test[query]), names(test[-query][j])), data = test, family = "binomial"(link=logit))
        }
    }
    <<fit>>
    odds = FUN.Odds(fit)
    info.temp = FUN.info.temp(odds)
    rest.temp[[i-1]] = rowSums(info.temp)
    query = c(query, which(names(test[-query][which(colMeans(info.temp) == max(colMeans(info.temp)))[1]]) == names(test))[1])
    modell[[i]] = fit[[which(colMeans(info.temp) == max(colMeans(info.temp)))[1]]]
}

if (length(test) == items)
{
    rest.temp[[items]] = rest.temp[[1]]*0
} else
{
    fit = NULL
    pcitems.temp = which(names(test[-query]) %in% names(test[pcitems]))
    
    for (j in 1:length(test[-query]))
    {
        if (j %in% pcitems.temp)
        {
            fit[[j]] = polr(reformulate(names(test[query]), names(test[-query][j])), data = test)
        } else
        {
            fit[[j]] = glm(reformulate(names(test[query]), names(test[-query][j])), data = test, family = "binomial"(link=logit))
        }
    }
    <<fit>>
    odds = FUN.Odds(fit)
    info.temp = FUN.info.temp(odds)
    rest.temp[[items]] = rowSums(info.temp)
}

pcitems.temp = which(query %in% pcitems)
rest.temp = simplify2array(rest.temp)
odds = FUN.Odds(modell)
info.temp = FUN.info.temp(odds)
entropie.SD.temp = sd(info.temp[,1])

for (i in 2:length(info.temp[1,]))
{
    entropie.SD.temp[i] = sd(rowSums(info.temp[,1:i]))
}

entropie.SD$durchschbedsort = c(0,entropie.SD.temp)
entropie$durchschbedsort = c(0,colMeans(info.temp))
info.rest$durchschbedsort = c(0,colMeans(rest.temp))
info.rest.SD$durchschbedsort = c(0,apply(rest.temp, 2, sd))
#+END_SRC

*** Adaptiv
**** Individuellbedingtsortierte info
Hier wird das zuletzt genannte Verfahren individualisiert, was den Rechenaufwand in diesem Fall 319 mal höher macht.
Das Ergebniss ist jedoch bereits ein echt adaptiver Test.
Somit ist die infokurve nun auch viel stärker gekrümmt (hat also eine größere zweite Ableitung).
Somit kann unter kleinem Informationsverlust der Test stark verkürzt werden.

Ideal wäre ein Itempool, der nicht komplett erschöpft wird in einer Testung. Somit könnte man berechnen, wie lang ein nichtadaptiver im Vergleich zu einem gleichpräzisen adaptiven Test ist.
#+NAME: statistic4
#+BEGIN_SRC R :exports code :results output :noweb yes
## initializing
infoall = NULL
odds = NULL
rest.temp = NULL
query = NULL
modell = NULL
rest.temp = NULL
pcitems.temp = pcitems
fit = NULL

## first item
for (i in 1:length(test))
{
    if (i %in% pcitems.temp)
    {
        fit[[i]] = polr(reformulate('1', names(test[i])), data = test)
    } else
    {
        fit[[i]] = glm(reformulate('1', names(test[i])), data = test, family = "binomial"(link=logit))
    }
}

odds = fit
odds[-pcitems.temp] = lapply(fit[-pcitems.temp], predict, test[1,], type="response")
odds[pcitems.temp] = lapply(fit[pcitems.temp], predict, test[1,], type="probs")
info.temp = FUN.info.temp.IND(odds)
query = which(names(test[which(info.temp == max(info.temp))[1]]) == names(test))[1]
modell[[1]] = fit[[query]]
queryinit = query
fit = NULL

## multicorecalculation for every person
infoall = simplify2array(foreach(k=1:persons) %dopar%
{
    query = queryinit
    entropie.rest = NULL
    
    for (i in 2:items)
    {
        odds = NULL
        info.temp = NULL
        fit = NULL
        pcitems.temp = c(0,which(names(test[-query]) %in% names(test[pcitems])))
        
        for (j in 1:length(test[-query]))
        {
            if (j %in% pcitems.temp)
            {
                fit[[j]] = polr(reformulate(names(test[query]), names(test[-query][j])), data = test)
            } else
            {
                fit[[j]] = glm(reformulate(names(test[query]), names(test[-query][j])), data = test, family = "binomial"(link=logit))
            }
        }
        
        <<fit>>
        odds = fit
        info.temp = FUN.EntroMC(pcitems.temp,test[k,], fit)
        rest.temp[i-1] = sum(info.temp) #rest of entropie before this item
        query = c(query, which(names(test[-query][which(info.temp == max(info.temp))[1]]) == names(test))[1])
        modell[[i]] = fit[[which(info.temp == max(info.temp))[1]]]
    }
    
    ## calculation of last rest entropie
    if (length(test) == items)
    {
        rest.temp[items] = 0
    } else
    {
        fit = NULL
        pcitems.temp = 0
        pcitems.temp = c(0,which(names(test[-query]) %in% names(test[pcitems])))
        
        for (j in 1:length(test[-query]))
        {
            if (j %in% pcitems.temp)
            {
                fit[[j]] = polr(reformulate(names(test[query]), names(test[-query][j])), data = test)
            } else
            {
                fit[[j]] = glm(reformulate(names(test[query]), names(test[-query][j])), data = test, family = "binomial"(link=logit))
            }
        }
        <<fit>>
        info.temp = FUN.EntroMC(pcitems.temp,test[k,], fit)
        rest.temp[items] = sum(info.temp)
    }
    
    ## calculation of the choosen modell
    pcitems.temp = c(0,which(query %in% pcitems))
    info.temp = FUN.EntroMC(pcitems.temp,test[k,], modell)
    return(c(info.temp, rest.temp))
})

rest.temp = (infoall[(items+1):(items*2),])
infoall = infoall[1:items,]
entropie.SD.temp = sd(infoall[1,])

for (i in 2:length(infoall[,1]))
{
    entropie.SD.temp[i] = sd(colSums(infoall[1:i,]))
}

entropie.SD$indivbedsort = c(0,entropie.SD.temp)
entropie$indivbedsort = c(0,rowMeans(infoall))
info.rest$indivbedsort = c(0,rowMeans(rest.temp))
info.rest.SD$indivbedsort = c(0,apply(rest.temp, 1, sd))
pcitems.temp = pcitems
#+END_SRC

**** Individuellbedingtsortierte info mit Trennschärfe
Ein nicht gut gelungener Versuch, nicht nur die info als Auswahlkriterium zu nehmen. Dies ist deswegen sinnvoll, da Items vorstellbar sind mit hoher info, die aber mit dem Test wenig zu tun haben (z.B. eine Frage nach der Schuhgröße hat vermutlich eine sehr hohe info, hat aber vermutlich wenig mit musikalischer Kompetenz zu tun).
Somit macht das bisherige Verfahren die Annahme, dass der Itempool sehr gut konstruiert ist.
Dementsprechend kann man das bisherige Verfahren sicher nicht als robust bezeichnen.
#+NAME: statistic5
#+BEGIN_SRC R :exports code :results output :noweb yes
infoall = NULL
odds = NULL
beta = NULL
rest.temp = NULL
info.temp = NULL
fit = NULL

if (!exists("information"))
{
    information = simplify2array(foreach(m=1:length(komus)) %dopar%
    {
        for (n in 1:(length(komus)-1))
        {
            beta[[n]] = glm(reformulate(names(komus[m]), names(komus[-m][n])), data = komus, family = "binomial"(link=logit))
        }
        odds = simplify2array(lapply(beta, predict, type="response"))
        chancetemp = unlist(lapply(komus[m],mean))
        info.temp = (-odds*log(odds,2)-(1-odds)*log(1-odds,2))
        information = sum(colMeans(info.temp)) + (-chancetemp*log(chancetemp,2)-(1-chancetemp)*log(1-chancetemp,2))
        return(information)
    })
    information = -(information - sum(-colMeans(komus)*log(colMeans(komus),2)-(1-colMeans(komus))*log(1-colMeans(komus),2)))
}

for (j in 1:length(komus))
{
    fit[[j]] = glm(reformulate('1', names(komus[j])), data = komus, family = "binomial"(link=logit))
}

<<fit>>
odds = simplify2array(lapply(fit, predict, komus[1,], type="response"))
info.temp = (-odds*log(odds,2)-(1-odds)*log(1-odds,2)) + (information)
queryinit = which(names(komus[which((info.temp) == max((info.temp)))[1]]) == names(komus))[1]
modell[[1]] = fit[[which((info.temp) == max((info.temp)))[1]]]

infoall = simplify2array(foreach(k=1:persons) %dopar%
{
    query = queryinit
    
    for (i in 2:items)
    {
        info.temp = NULL
        fit = NULL
        
        for (j in 1:length(komus[-query]))
        {
            fit[[j]] = glm(reformulate(names(komus[query]), names(komus[-query][j])), data = komus, family = "binomial"(link=logit))
        }
        
        <<fit>>
        ## TODO stimmt das so?
        odds = simplify2array(lapply(fit, predict, komus[k,], type="response"))
        rest.temp[i-1] = sum(-odds*log(odds,2)-(1-odds)*log(1-odds,2)) 
        info.temp = (-odds*log(odds,2)-(1-odds)*log(1-odds,2)) + (information[-query]*(1 - (length(query)+1)/items))
        query = c(query, which(names(komus[-query][which((info.temp) == max((info.temp)))[1]]) == names(komus))[1])
        modell[[i]] = fit[[which((info.temp) == max((info.temp)))[1]]]
    }
    
    if (length(komus) == items)
    {
        rest.temp[items] = 0
    } else
    {
        fit = NULL
        
        for (j in 1:length(komus[-query]))
        {
            fit[[j]] = glm(reformulate(names(komus[query]), names(komus[-query][j])), data = komus, family = "binomial"(link=logit))
        }
        <<fit>>
        odds = simplify2array(lapply(fit, predict, komus[k,], type="response"))
        rest.temp[length(query)] = sum(-odds*log(odds,2)-(1-odds)*log(1-odds,2))
    }
    
    odds = simplify2array(lapply(modell, predict, komus[k,], type="response"))
    info.temp = (-odds*log(odds,2)-(1-odds)*log(1-odds,2))
    return(c(info.temp, rest.temp))
})

rest.temp = (infoall[(items+1):(items*2),])
infoall = infoall[1:items,]
entropie.SD.temp = sd(infoall[1,])

for (i in 2:length(infoall[,1]))
{
    entropie.SD.temp[i] = sd(colSums(infoall[1:i,]))
}

entropie.SD$indivbedsorttrenn = c(0,entropie.SD.temp )
entropie$indivbedsorttrenn = c(0,rowMeans(infoall))
info.rest$indivbedsorttrenn = c(0,rowMeans(rest.temp))
info.rest.SD$indivbedsorttrenn = c(0,apply(rest.temp,1 ,sd))
#+END_SRC

**** Individuellbedingtsortierte info mit Prädiktion
Hier wird nun die info rekursiv berechnet.
Es wird nicht nur geschaut, welches Item die meiste info besitzt, sondern es werden für jedes Item alle Antwortmöglichkeiten simuliert und mit dieser Simulation die verbleibende info im gesamten Test errechnet, diese mit der Chance der simulierten Antwort gewichtet und aufaddiert mit den gewichteten anderen Antwortmöglichkeiten.

Dieses Modell umgeht also das Problem der vorherigen beiden.
Es ist sehr robust, weil immer auch berechnet wird, wie sehr sich das auserwählte Item mit all seinen Antwortmöglichkeiten auf die gesamte entropie.rest auswirkt.
Dies ist eine mächtigere Form der Trennschärfe, weil sie nicht starr, sondern antwortmusterspezifisch ist.

Dieses Modell bringt die rechnerischen Anforderungen auf ein neues Niveau, sie werden nochmals ungefähr 30 mal höher.
Als Konsequenz daraus habe ich hier eine Datenbank mit implementiert, die einerseits bereits berechnetes speichert um mir wiederholte Arbeit zu ersparen und andererseits stets schaut, ob Frage-Antwort-Kombinationen bereits bei anderen Schülern vorgekommen ist, um mit Hilfe dieses Wissens hin und wieder einzelne Rechnungen zu ersparen.

Zunächst könnte man denken, dass es bei rund 50 binären Items $2^{50}$ Möglichkeiten der Antwortmuster gibt, was die Datenbank als sinnlos erscheinen lässt.
Jedoch muss bedacht werden, dass die Antwort Reihenfolge in der aktuellen Regression keine Rolle spielt. Beantwortet man Item a, b, und c richtig und bekommt daraufhin Item c, so würde man dies genauso bekommen, wenn man b, c und dann erst a richtig beantwortet, was die Sinnhaftigkeit der Datenbank deutlich steigert.
Zudem werden manche Antwortmuster und manche Items gehäuft vorkommen, weil sie entweder besonders qualitativ, oder besonders »normal« sind.
Im Moment fangen beispielsweise alle Schüler mit dem gleichen, maximal informativen Item an, weil noch keine Vorinformation über die Schüler vorhanden ist.
#+NAME: statistic6
#+BEGIN_SRC R :exports code :results output :noweb yes
## initializing
fit = NULL
infoall = NULL
odds = NULL
rest.temp = NULL
query = NULL
modell = NULL
rest.temp = NULL
pcitems.temp = pcitems

## first item
for (i in 1:length(test)) {
    if (i %in% pcitems.temp) {
        fit[[i]] = polr(reformulate('1', names(test[i])), data = test)
    } else {
        fit[[i]] = glm(reformulate('1', names(test[i])), data = test, family = "binomial"(link=logit))
    }
}

odds = fit
odds[-pcitems.temp] = lapply(fit[-pcitems.temp], predict, test[1,], type="response")
odds[pcitems.temp] = lapply(fit[pcitems.temp], predict, test[1,], type="probs")
info.temp = FUN.info.temp.IND(odds)
query = which(names(test[which(info.temp == max(info.temp))[1]]) == names(test))[1]

modell[[1]] = fit[[query]]
queryinit = query
fit = NULL
entropie.rest2 = NULL

## multicore calculation
infoall = simplify2array(foreach(k=1:persons) %dopar% {
    query = queryinit
    entropie.rest = NULL
    rest.temp2 = NULL
    rest.temp = NULL
    for (i in 2:items) {
        odds = NULL
        info.temp = NULL
        fit = NULL
        fit2 = NULL
        fitplus = NULL
        fitminus = NULL
        info.temp2 = NULL
        pcitems.temp = 0
        pcitems.temp = c(pcitems.temp,which(names(test[-query]) %in% names(test[pcitems])))

        ## prediction for all not-answerd questions
        for (j in 1:length(test[-query])) {
            if (j %in% pcitems.temp) {
                fit[[j]] = polr(reformulate(names(test[query]), names(test[-query][j])), data = test)
            } else {
                fit[[j]] = glm(reformulate(names(test[query]), names(test[-query][j])), data = test, family = "binomial"(link=logit))
            }

            ## prediction for all not-answered questions after prediction
            if (length(test[-query]) > 1) {
                pcitems.temp2 = c(0,which(names(test[-query][-j]) %in% names(test[pcitems])))
                for (n in 1:length(test[-query][-j])) {
                    if (n %in% pcitems.temp2) {
                        fit2[[n]] = polr(reformulate(names(c(test[query], test[-query][j])), names(test[-query][-j][n])), data = test)
                    } else {
                        fit2[[n]] = glm(reformulate(names(c(test[query], test[-query][j])), names(test[-query][-j][n])), data = test, family = "binomial"(link=logit))
                    }
                }

                ## calculation of rest entropie for each possibility
                tempdata = test[k,]
                ##tempdata[-query][j] = 0 #dies muss noch bearbeitet werden (chancen...)
                <<fit>>
                    #                        odds = fit2
                    #                    if (length(pcitems.temp2) == 1) {
                    #                        odds = lapply(fit2, predict, tempdata, type="response")
                    #                        info.temp = odds
                    #                        info.temp = lapply(odds, FUN.info)
                    #                        info.temp = simplify2array(info.temp)
                    #                    } else {
                    #                        pcitems.temp2 = pcitems.temp2[2:length(pcitems.temp2)]
                    #                        odds[-pcitems.temp2] = lapply(fit2[-pcitems.temp2], predict, tempdata, type="response")
                    #                        odds[pcitems.temp2] = lapply(fit2[pcitems.temp2], predict, tempdata, type="probs")
                    #                        info.temp = odds

                    #                        ## Funktion kann nicht benutzt werden, da sie auf nicht manipulierte pcitems.temp zugreift
                    #                        info.temp[pcitems.temp2] = lapply(odds[pcitems.temp2], FUN.infoMC.IND)
                    #                        info.temp[-pcitems.temp2] = lapply(odds[-pcitems.temp2], FUN.info)
                    #                        info.temp = simplify2array(info.temp)
                    #                    }
                    info.temp = FUN.EntroMC(pcitems.temp2,tempdata, fit2)
                rest.temp2[j] = sum(info.temp)
            } else {
                rest.temp2[j] = 0 
            }
        }

        <<fit>>
            odds = fit

        #            ## calculation of current rest entropie
        #            if (length(pcitems.temp) == 1) {
        #                odds = lapply(fit, predict, test[k,], type="response")
        #                info.temp = odds
        #                info.temp = lapply(odds, FUN.info)
        #                info.temp = simplify2array(info.temp)
        #            } else {
        #                pcitems.temp = pcitems.temp[2:length(pcitems.temp)]
        #                odds[-pcitems.temp] = lapply(fit[-pcitems.temp], predict, test[k,], type="response")
        #                odds[pcitems.temp] = lapply(fit[pcitems.temp], predict, test[k,], type="probs")
        #                info.temp = odds

        #                ## Funktion kann nicht benutzt werden, da sie auf nicht manipulierte pcitems.temp zugreift
        #                info.temp[pcitems.temp] = lapply(odds[pcitems.temp], FUN.infoMC.IND)
        #                info.temp[-pcitems.temp] = lapply(odds[-pcitems.temp], FUN.info)
        #                info.temp = simplify2array(info.temp)
        #            }
        info.temp = FUN.EntroMC(pcitems.temp,test[k,], fit)
        rest.temp[i-1] = sum(info.temp)
        query = c(query, which(names(test[-query][which(rest.temp2 == min(rest.temp2))[1]]) == names(test))[1])
        ## stimmt das? sollte das nicht mit rest.temp2 arbeiten?
        ##        modell[[i]] = fit[[which(info.temp == max(info.temp))]]
        modell[[i]] = fit[[which(rest.temp2 == min(rest.temp2))[1]]]
    }

    ## calculation of last rest entropie
    if (length(test) == items) {
        rest.temp[items] = 0
    } else {
        fit = NULL
        pcitems.temp = 0
        pcitems.temp = c(0,which(names(test[-query]) %in% names(test[pcitems])))
        for (j in 1:length(test[-query])) {
            if (j %in% pcitems.temp) {
                fit[[j]] = polr(reformulate(names(test[query]), names(test[-query][j])), data = test)
            } else {
                fit[[j]] = glm(reformulate(names(test[query]), names(test[-query][j])), data = test, family = "binomial"(link=logit))
            }
        }

        <<fit>>
            #                if (length(pcitems.temp) == 1) {
            #                    odds = lapply(fit, predict, test[k,], type="response")
            #                    info.temp = odds
            #                    info.temp = lapply(odds, FUN.info)
            #                    info.temp = simplify2array(info.temp) 
            #                } else {
            #                    pcitems.temp = pcitems.temp[2:length(pcitems.temp)]
            #                    odds[-pcitems.temp] = lapply(fit[-pcitems.temp], predict, test[k,], type="response")
            #                    odds[pcitems.temp] = lapply(fit[pcitems.temp], predict, test[k,], type="probs")
            #                    info.temp = odds

            #                    ## Funktion kann nicht benutzt werden, da sie auf nicht manipulierte pcitems.temp zugreift
            #                    info.temp[pcitems.temp] = lapply(odds[pcitems.temp], FUN.infoMC.IND)
            #                    info.temp[-pcitems.temp] = lapply(odds[-pcitems.temp], FUN.info)
            #                    info.temp = simplify2array(info.temp)
            #                }
            info.temp = FUN.EntroMC(pcitems.temp,test[k,], fit)
        rest.temp[items] = sum(info.temp)
    }

    ## calculation of choosen modell
    pcitems.temp = 0
    pcitems.temp = c(pcitems.temp,which(query %in% pcitems))
    #        if (length(pcitems.temp) == 1) {
    #            odds = modell
    #            odds = lapply(modell, predict, test[k,], type="response")
    #            info.temp = odds
    #            info.temp = lapply(odds, FUN.info)
    #            info.temp = simplify2array(info.temp)
    #        } else {
    #            pcitems.temp = pcitems.temp[2:length(pcitems.temp)]
    #            odds = modell
    #            odds[-pcitems.temp] = lapply(modell[-pcitems.temp], predict, test[k,], type="response")
    #            odds[pcitems.temp] = lapply(modell[pcitems.temp], predict, test[k,], type="probs")
    #            info.temp = odds

    #            ## Funktion kann nicht benutzt werden, da sie auf nicht manipulierte pcitems.temp zugreift
    #            info.temp[pcitems.temp] = lapply(odds[pcitems.temp], FUN.infoMC.IND)
    #            info.temp[-pcitems.temp] = lapply(odds[-pcitems.temp], FUN.info)
    #            info.temp = simplify2array(info.temp)
    #        }
    info.temp = FUN.EntroMC(pcitems.temp,test[k,], modell)
    return(c(info.temp, rest.temp))
})

rest.temp = (infoall[(items+1):(items*2),])
infoall = infoall[1:items,]

entropie.SD.temp = sd(infoall[1,])
for (i in 2:length(infoall[,1])) {
    entropie.SD.temp[i] = sd(colSums(infoall[1:i,]))
}

entropie.SD$indivbedsortpred = c(0,entropie.SD.temp)
entropie$indivbedsortpred = c(0,rowMeans(infoall))
info.rest$indivbedsortpred = c(0,rowMeans(rest.temp))
info.rest.SD$indivbedsortpred = c(0,apply(rest.temp, 1, sd))

pcitems.temp = pcitems
entropie
entropie.SD
info.rest
info.rest.SD
#+END_SRC

*** Experimenteller Code
#+BEGIN_SRC R :exports code :results output :noweb yes
calculationtime <- proc.time()

## initializing
fit = NULL
infoall = NULL
odds = NULL
rest.temp = NULL
query = NULL
modell = NULL
rest.temp = NULL
pcitems.temp = pcitems

## first item
for (i in 1:length(test)) {
    if (i %in% pcitems.temp) {
        fit[[i]] = polr(reformulate('1', names(test[i])), data = test)
    } else {
        fit[[i]] = glm(reformulate('1', names(test[i])), data = test, family = "binomial"(link=logit))
    }
}

odds = fit
odds[-pcitems.temp] = lapply(fit[-pcitems.temp], predict, test[1,], type="response")
odds[pcitems.temp] = lapply(fit[pcitems.temp], predict, test[1,], type="probs")
info.temp = FUN.info.temp.IND(odds)
query = which(names(test[which(info.temp == max(info.temp))[1]]) == names(test))[1]

modell[[1]] = fit[[query]]
queryinit = query
fit = NULL
entropie.rest2 = NULL
infoall = matrix(nrow=persons,ncol=items)
## multicore calculation
#    infoall = simplify2array(foreach(k=1:persons) %dopar% {
for (k in 1:persons) {
    query = queryinit
    entropie.rest = NULL
    rest.temp2 = NULL
    rest.temp = NULL
    calcu = 0
    calcutime = proc.time()
    answers = vector(length=(length(test)+2))
    if (file.exists('database.dat')) {
        database = read.table('database.dat')
    }
    answers[1] = query[1] + as.numeric(as.character(test[k,query[1]]))/100
    #                answers[2] = test[k,query[1]]
    for (i in 2:items) {
        odds = NULL
        info.temp = NULL
        fit = NULL
        fit2 = NULL
        fitplus = NULL
        fitminus = NULL
        info.temp2 = NULL
        found = 0
        pcitems.temp = c(0,which(names(test[-query]) %in% names(test[pcitems])))
        Liste = NULL
        foundit = 0
        ## prediction for all not-answerd questions
        if (exists("database")) {
            for (m in 1:length(database[,1])) {
                for (u in 1:length(query)) {
                    if (sort(answers[1:length(query)])[u] != database[m,u]) {
                        break
                    }
                    if (database[m,(length(query)+3)] == 0 && u == length(query)) {
                        found = database[m,(length(query)+2)]
                        rest.temp[i-1] = database[m,(length(query)+1)]
                        query = c(query, found)
                    }
                }
                if (found != 0) {
                    break
                }
            }
        }
        if (found == 0) {
            calcu = calcu+1
            isgood = NULL
            for (q in 1:length(test[-query])) {
                if (q %in% pcitems.temp) {
                    fit[[q]] = polr(reformulate(names(test[query]), names(test[-query][q])), data = test)
                } else {
                    fit[[q]] = glm(reformulate(names(test[query]), names(test[-query][q])), data = test, family = "binomial"(link=logit))
                }
            }
            info.temp = FUN.EntroMC(pcitems.temp,test[k,], fit)
            isgood = info.temp >= (max(info.temp)[1] * 0.8)
            Liste =foreach(j=1:length(test[-query])) %dopar% {
                chance = NULL
                if (j %in% pcitems.temp) {
                    #    fit = polr(reformulate(names(test[query]), names(test[-query][j])), data = test)
                    chance = predict(fit[[j]], test[k,], type="probs")
                } else {
                    #                                                    fit = glm(reformulate(names(test[query]), names(test[-query][j])), data = test, family = "binomial"(link=logit))
                    chance = predict(fit[[j]], test[k,], type="response")
                    chance[2] = 1-chance[1]
                }
                #                                             info.temp = FUN.EntroMC(pcitems.temp,test[k,], fit)
                #      tempdata = test[k,]
                #          if (j %in% pcitems.temp) {
                #              for (s in 1:length(chance)) {
                #                  tempdata[-query][j] = factor(s-1) #dies muss noch bearbeitet werden (chancen...)
                #                  info.temp = FUN.EntroMC(pcitems.temp,tempdata, fit)*chance[s]
                #                  rest.temp2[s] = sum(info.temp)
                #              }
                #              rest.temp2 = sum(rest.temp2)
                #          } else {
                #              tempdata[-query][j] = 1
                #              info.temp = FUN.EntroMC(pcitems.temp2,tempdata, fit2)*chance[1]
                #              rest.temp2 = sum(info.temp)
                #              tempdata[-query][j] = 0
                #              info.temp = FUN.EntroMC(pcitems.temp2,tempdata, fit2)*chance[2]
                #              rest.temp2[2] = sum(info.temp)
                #              rest.temp2 = sum(rest.temp2)
                #          }
                #          fit2=NULL

                rest.temp2 = NULL
                ## prediction for all not-answered questions after prediction
                if (length(test[-query]) > 1 && isgood[j]) {
                    pcitems.temp2 = c(0,which(names(test[-query][-j]) %in% names(test[pcitems])))
                    for (n in 1:length(test[-query][-j])) {
                        if (n %in% pcitems.temp2) {
                            fit2[[n]] = polr(reformulate(names(c(test[query], test[-query][j])), names(test[-query][-j][n])), data = test)
                        } else {
                            fit2[[n]] = glm(reformulate(names(c(test[query], test[-query][j])), names(test[-query][-j][n])), data = test, family = "binomial"(link=logit))
                        }
                    }

                    ## calculation of rest entropie for each possibility
                    tempdata = test[k,]
                    if (j %in% pcitems.temp) {
                                    for (s in 1:length(chance)) {
                                        tempdata[-query][j] = factor(s-1) #dies muss noch bearbeitet werden (chancen...)
                                        info.temp = FUN.EntroMC(pcitems.temp2,tempdata, fit2)*chance[s]
                                        rest.temp2[s] = sum(info.temp)
                                                                                    }
                                    rest.temp2 = sum(rest.temp2)
                        #info.temp = FUN.EntroMC(pcitems.temp2,tempdata, fit2)
                        #rest.temp2 = sum(info.temp)

                    } else {
                        tempdata[-query][j] = 1
                        info.temp = FUN.EntroMC(pcitems.temp2,tempdata, fit2)*chance[1]
                        rest.temp2 = sum(info.temp)
                        tempdata[-query][j] = 0
                        info.temp = FUN.EntroMC(pcitems.temp2,tempdata, fit2)*chance[2]
                        rest.temp2[2] = sum(info.temp)
                        rest.temp2 = sum(rest.temp2)
                    }
                    fit2=NULL
                } else {
                    if (isgood[j]) {
                        rest.temp2 = 0
                    } else {
                        rest.temp2 = 55555555
                    }
                }
                return(rest.temp2)
            }
            #                                             Liste = unlist(Liste, recursive = FALSE)

            #                                             rest.temp2 = unlist(Liste[(1:(length(Liste)/2))*2])
            #                                             fit = Liste[(1:(length(Liste)/2))*2-1]
            rest.temp2 = simplify2array(Liste)
            query = c(query, which(names(test[-query][which(rest.temp2 == min(rest.temp2))[1]]) == names(test))[1])
            modell[[i]] = fit[[which(rest.temp2 == min(rest.temp2))[1]]]
            <<fit>>
                odds = fit

            info.temp = FUN.EntroMC(pcitems.temp,test[k,], fit)
            rest.temp[i-1] = sum(info.temp)

        }
        answers[i] = query[i] + as.numeric(as.character(test[k,query[i]]))/100

        if (found == 0) {
            temp = answers
            temp[1:(i-1)] = sort(answers[1:(i-1)])
            temp[i] = rest.temp[i-1]
            temp[i+1] = query[i]
            write(temp, file='database.dat', append=TRUE, ncolumns=length(answers))
        }
        plot(rest.temp, type='l', col=rgb(0,0.7,0.7))
    }
    ## calculation of last rest entropie
    if (length(test) == items) {
        rest.temp[items] = 0
    } else {
        fit = NULL
        pcitems.temp = 0
        pcitems.temp = c(0,which(names(test[-query]) %in% names(test[pcitems])))
        for (j in 1:length(test[-query])) {
            if (j %in% pcitems.temp) {
                fit[[j]] = polr(reformulate(names(test[query]), names(test[-query][j])), data = test)
            } else {
                fit[[j]] = glm(reformulate(names(test[query]), names(test[-query][j])), data = test, family = "binomial"(link=logit))
            }
        }

        <<fit>>

            info.temp = FUN.EntroMC(pcitems.temp,test[k,], fit)
        rest.temp[items] = sum(info.temp)
    }

    ## calculation of choosen modell
    pcitems.temp = 0
    pcitems.temp = c(pcitems.temp,which(query %in% pcitems))
    if (calcu != 0) {
        temp = vector(length=(length(test)+2))
        temp[2] = k
        temp[3] = (proc.time() - calcutime)[3]
        temp[4] = calcu
        write(temp, file='database.dat', append=TRUE, ncolumns=length(answers))
    }
    #info.temp = FUN.EntroMC(pcitems.temp,test[k,], modell)
    #    return(c(info.temp, rest.temp))
    infoall[k,] = rest.temp
}#})

#restt = (infoall[(items+1):(items*2),])
#infoall = infoall[1:items,]

#    entropie.SD.temp = sd(infoall[1,])
#   for (i in 2:length(infoall[,1])) {
#      entropie.SD.temp[i] = sd(colSums(infoall[1:i,]))
# }

#entropie.SD$indivbedsortpred = c(0,entropie.SD.temp)
#entropie$indivbedsortpred = c(0,rowMeans(infoall))
info.rest$indivbedsortpred = c(0,colMeans(infoall))
info.rest.SD$indivbedsortpred = c(0,apply(infoall, 2, sd))

pcitems.temp = pcitems
#entropie
#entropie.SD
info.rest
info.rest.SD
#+END_SRC

#+RESULTS:
#+begin_example
 Es gab 50 oder mehr Warnungen (Anzeige der ersten 50 mit warnings())
   kill indivbedsortpred
1    NA     0.000000e+00
2    NA     5.178416e+01
3    NA     4.916337e+01
4    NA     4.566564e+01
5    NA     4.359631e+01
6    NA     4.159470e+01
7    NA     4.082654e+01
8    NA     3.915497e+01
9    NA     3.749386e+01
10   NA     3.678568e+01
11   NA     3.532201e+01
12   NA     3.478900e+01
13   NA     3.362443e+01
14   NA     3.214838e+01
15   NA     3.145607e+01
16   NA     2.949048e+01
17   NA     2.840046e+01
18   NA     2.704249e+01
19   NA     2.522070e+01
20   NA     2.390117e+01
21   NA     2.285837e+01
22   NA     2.138640e+01
23   NA     2.018033e+01
24   NA     1.893426e+01
25   NA     1.852548e+01
26   NA     1.715495e+01
27   NA     1.590440e+01
28   NA     1.499250e+01
29   NA     1.377086e+01
30   NA     1.276547e+01
31   NA     1.162250e+01
32   NA     1.030836e+01
33   NA     9.559273e+00
34   NA     8.476659e+00
35   NA     8.269190e+00
36   NA     7.469053e+00
37   NA     6.842426e+00
38   NA     6.075166e+00
39   NA     5.484574e+00
40   NA     4.795565e+00
41   NA     4.022908e+00
42   NA     3.420260e+00
43   NA     2.941864e+00
44   NA     2.320071e+00
45   NA     2.010199e+00
46   NA     1.455297e+00
47   NA     1.005096e+00
48   NA     7.026305e-01
49   NA     4.921134e-01
50   NA     2.107218e-01
51   NA     1.053573e-01
52   NA     2.072936e-02
53   NA     8.718869e-03
54   NA    -1.442694e-06
55   NA     0.000000e+00
   kill indivbedsortpred
1    NA                0
2    NA               NA
3    NA               NA
4    NA               NA
5    NA               NA
6    NA               NA
7    NA               NA
8    NA               NA
9    NA               NA
10   NA               NA
11   NA               NA
12   NA               NA
13   NA               NA
14   NA               NA
15   NA               NA
16   NA               NA
17   NA               NA
18   NA               NA
19   NA               NA
20   NA               NA
21   NA               NA
22   NA               NA
23   NA               NA
24   NA               NA
25   NA               NA
26   NA               NA
27   NA               NA
28   NA               NA
29   NA               NA
30   NA               NA
31   NA               NA
32   NA               NA
33   NA               NA
34   NA               NA
35   NA               NA
36   NA               NA
37   NA               NA
38   NA               NA
39   NA               NA
40   NA               NA
41   NA               NA
42   NA               NA
43   NA               NA
44   NA               NA
45   NA               NA
46   NA               NA
47   NA               NA
48   NA               NA
49   NA               NA
50   NA               NA
51   NA               NA
52   NA               NA
53   NA               NA
54   NA               NA
55   NA               NA
#+end_example

*** Exp2, ersetzt präd.
#+BEGIN_SRC R :session stat :exports code :results output :noweb yes
## initializing

infoall = NULL
rest.temp = NULL

pcitems.temp = pcitems

## first item
fit = NULL
for (i in 1:length(test)) 
{
    if (i %in% pcitems)
    {
        fit[[i]] = polr(reformulate('1', names(test[i])), data = test)
    } else
    {
        fit[[i]] = glm(reformulate('1', names(test[i])), data = test, family = "binomial"(link=logit))
    }
}

odds = fit
odds[-pcitems.temp] = lapply(fit[-pcitems], predict, test[1,], type="response")
odds[pcitems.temp] = lapply(fit[pcitems], predict, test[1,], type="probs")
info.temp = FUN.info.temp.IND(odds)
query = which(names(test[which(info.temp == max(info.temp))[1]]) == names(test))[1]
modell = NULL
modell[[1]] = fit[[query]]
queryinit = query
fit = NULL
entropie.rest2 = NULL
infoall = matrix(nrow=persons,ncol=items)

for (k in 285:persons)
{
    query = queryinit
    entropie.rest = NULL
    rest.temp2 = NULL
    rest.temp = NULL
    calcu = 0
    calcutime = proc.time()
    answers = vector(length = (length(test)+2))
    
    if (file.exists('database.dat'))
    {
        database = read.table('database.dat')
    }
    
    answers[1] = query[1] + as.numeric(as.character(test[k,query[1]]))/100
    
    for (i in 2:items)
    {
        odds = NULL
        info.temp = NULL
        fit = NULL
        fit2 = NULL
        info.temp2 = NULL
        found = 0
        pcitems.temp = c(0, which(names(test[-query]) %in% names(test[pcitems])))
        foundit = 0
        
        # prediction for all not-answerd questions
        if (exists("database"))
        {
            for (m in 1:length(database[,1]))
            {
                for (u in 1:length(query))
                {
                    if (sort(answers[1:length(query)])[u] != database[m,u])
                    {
                        break
                    }
                    
                    if (database[m,(length(query)+3)] == 0 && u == length(query))
                    {
                        found = database[m,(length(query)+2)]
                        rest.temp[i-1] = database[m,(length(query)+1)]
                        query = c(query, found)
                    }
                }
                
                if (found != 0)
                {                   
                    break
                }
            }
        }
        
        if (found == 0)
        {
            calcu = calcu+1
            isgood = NULL
            
            for (q in 1:length(test[-query]))
            {
                if (q %in% pcitems.temp)
                {
                    fit[[q]] = polr(reformulate(names(test[query]), names(test[-query][q])), data = test)
                } else
                {
                    fit[[q]] = glm(reformulate(names(test[query]), names(test[-query][q])), data = test, family = "binomial"(link=logit))   
                }
            }
            
            info.temp = FUN.EntroMC(pcitems.temp,test[k,], fit)
            isgood = info.temp >= (max(info.temp)[1] * 0.8)
            
            Liste = foreach(j=1:length(test[-query])) %dopar%
            {
                chance = NULL
                
                if (j %in% pcitems.temp)
                {
                    chance = predict(fit[[j]], test[k,], type="probs")
                } else
                {
                    chance = predict(fit[[j]], test[k,], type="response")
                    chance[2] = 1-chance[1]
                }
                
                rest.temp2 = NULL
                
                ## prediction for all not-answered questions after prediction
                if (length(test[-query]) > 1 && isgood[j])
                {
                    pcitems.temp2 = c(0,which(names(test[-query][-j]) %in% names(test[pcitems])))
                    
                    for (n in 1:length(test[-query][-j]))
                    {
                        if (n %in% pcitems.temp2)
                        {
                            fit2[[n]] = polr(reformulate(names(c(test[query], test[-query][j])), names(test[-query][-j][n])), data = test)
                        } else
                        { 
                            fit2[[n]] = glm(reformulate(names(c(test[query], test[-query][j])), names(test[-query][-j][n])), data = test, family = "binomial"(link=logit))
                        }
                    }
                    
                    ## calculation of rest entropie for each possibility
                    tempdata = test[k,]
                    
                    if (j %in% pcitems.temp)
                    {
                        for (s in 1:length(chance))
                        {
                            tempdata[-query][j] = factor(s-1) #dies muss noch bearbeitet werden (chancen...)
                            info.temp = FUN.EntroMC(pcitems.temp2,tempdata, fit2)*chance[s]
                            rest.temp2[s] = sum(info.temp)
                        }
                        
                        rest.temp2 = sum(rest.temp2)
                    } else
                    {
                        tempdata[-query][j] = 1
                        info.temp = FUN.EntroMC(pcitems.temp2,tempdata, fit2)*chance[1]
                        rest.temp2 = sum(info.temp)
                        tempdata[-query][j] = 0
                        info.temp = FUN.EntroMC(pcitems.temp2,tempdata, fit2)*chance[2]
                        rest.temp2[2] = sum(info.temp)
                        rest.temp2 = sum(rest.temp2)
                    }
                    
                    fit2=NULL
                } else
                {
                    if (isgood[j])
                    {
                        rest.temp2 = 0
                        
                    } else {
                        
                        rest.temp2 = 55555555
                    }
                }
                
                return(rest.temp2)
            }
            
            rest.temp2 = simplify2array(Liste)
            query = c(query, which(names(test[-query][which(rest.temp2 == min(rest.temp2))[1]]) == names(test))[1])
            modell[[i]] = fit[[which(rest.temp2 == min(rest.temp2))[1]]]
            <<fit>>
            odds = fit
            info.temp = FUN.EntroMC(pcitems.temp,test[k,], fit)
            rest.temp[i-1] = sum(info.temp)
        }
        
        answers[i] = query[i] + as.numeric(as.character(test[k,query[i]]))/100
        
        if (found == 0) 
        {
            temp = answers
            temp[1:(i-1)] = sort(answers[1:(i-1)])
            temp[i] = rest.temp[i-1]
            temp[i+1] = query[i]
            write(temp, file='database.dat', append=TRUE, ncolumns=length(answers))
        }
        
        plot(rest.temp, type='l', col=rgb(0,0.7,0.7))
    }
    
    ## calculation of last rest entropie
    if (length(test) == items)
    {
        rest.temp[items] = 0
    } else
    {
        fit = NULL
        pcitems.temp = 0
        pcitems.temp = c(0,which(names(test[-query]) %in% names(test[pcitems])))
        
        for (j in 1:length(test[-query]))
        {
            if (j %in% pcitems.temp)
            {
                fit[[j]] = polr(reformulate(names(test[query]), names(test[-query][j])), data = test)
            } else
            {
                fit[[j]] = glm(reformulate(names(test[query]), names(test[-query][j])), data = test, family = "binomial"(link=logit))
            }
        }
        
        <<fit>>
        info.temp = FUN.EntroMC(pcitems.temp,test[k,], fit)
        rest.temp[items] = sum(info.temp)
    }
    
    ## calculation of choosen modell
    pcitems.temp = 0
    pcitems.temp = c(pcitems.temp,which(query %in% pcitems))
    
    if (calcu != 0)
    {
        temp = vector(length=(length(test)+2))
        temp[2] = k
        temp[3] = (proc.time() - calcutime)[3]
        temp[4] = calcu
        write(temp, file='database.dat', append=TRUE, ncolumns=length(answers))
    }
    
    infoall[k,] = rest.temp
}

#restt = (infoall[(items+1):(items*2),])
#infoall = infoall[1:items,]

#    entropie.SD.temp = sd(infoall[1,])
#   for (i in 2:length(infoall[,1])) {
#      entropie.SD.temp[i] = sd(colSums(infoall[1:i,]))
# }

#entropie.SD$indivbedsortpred = c(0,entropie.SD.temp)
#entropie$indivbedsortpred = c(0,rowMeans(infoall))
info.rest$indivbedsortpred = c(0,colMeans(infoall))
info.rest.SD$indivbedsortpred = c(0,apply(infoall, 2, sd))

pcitems.temp = pcitems
#entropie
#entropie.SD
info.rest
info.rest.SD
#+END_SRC

#+RESULTS:
#+begin_example
 Es gab 50 oder mehr Warnungen (Anzeige der ersten 50 mit warnings())
   kill indivbedsortpred
1    NA                0
2    NA               NA
3    NA               NA
4    NA               NA
5    NA               NA
6    NA               NA
7    NA               NA
8    NA               NA
9    NA               NA
10   NA               NA
11   NA               NA
12   NA               NA
13   NA               NA
14   NA               NA
15   NA               NA
16   NA               NA
17   NA               NA
18   NA               NA
19   NA               NA
20   NA               NA
21   NA               NA
22   NA               NA
23   NA               NA
24   NA               NA
25   NA               NA
26   NA               NA
27   NA               NA
28   NA               NA
29   NA               NA
30   NA               NA
31   NA               NA
32   NA               NA
33   NA               NA
34   NA               NA
35   NA               NA
36   NA               NA
37   NA               NA
38   NA               NA
39   NA               NA
40   NA               NA
41   NA               NA
42   NA               NA
43   NA               NA
44   NA               NA
45   NA               NA
46   NA               NA
47   NA               NA
48   NA               NA
49   NA               NA
50   NA               NA
51   NA               NA
52   NA               NA
53   NA               NA
54   NA               NA
55   NA               NA
   kill indivbedsortpred
1    NA                0
2    NA               NA
3    NA               NA
4    NA               NA
5    NA               NA
6    NA               NA
7    NA               NA
8    NA               NA
9    NA               NA
10   NA               NA
11   NA               NA
12   NA               NA
13   NA               NA
14   NA               NA
15   NA               NA
16   NA               NA
17   NA               NA
18   NA               NA
19   NA               NA
20   NA               NA
21   NA               NA
22   NA               NA
23   NA               NA
24   NA               NA
25   NA               NA
26   NA               NA
27   NA               NA
28   NA               NA
29   NA               NA
30   NA               NA
31   NA               NA
32   NA               NA
33   NA               NA
34   NA               NA
35   NA               NA
36   NA               NA
37   NA               NA
38   NA               NA
39   NA               NA
40   NA               NA
41   NA               NA
42   NA               NA
43   NA               NA
44   NA               NA
45   NA               NA
46   NA               NA
47   NA               NA
48   NA               NA
49   NA               NA
50   NA               NA
51   NA               NA
52   NA               NA
53   NA               NA
54   NA               NA
55   NA               NA
#+end_example






*** Schlussberechnungen
Hier werden lediglich ein paar Aufräumarbeiten in den Daten noch erledigt, um diese dann gut zeichnen zu können.
#+NAME: statisticend
#+BEGIN_SRC R :exports code :results output :noweb yes
if (names(entropie[1]) == 'kill')
{
    entropie = entropie[-1]
}

if (names(entropie.SD[1]) == 'kill')
{
    entropie.SD = entropie.SD[-1]
}

if (names(info.rest[1]) == 'kill')
{
    info.rest = info.rest[-1]
    info.rest.SD = info.rest.SD[-1]
}

for (i in 1:length(entropie[1,]))
{
    for (j in 1:length(entropie[,1]))
    {
        summe[j,i] = sum(entropie[1:j,i])
    }
}

fit = NULL
pcitems.temp = pcitems

for (i in 1:length(test))
{
    if (i %in% pcitems.temp)
    {
        fit[[i]] = polr(reformulate('1', names(test[i])), data = test)
    } else
    {
        fit[[i]] = glm(reformulate('1', names(test[i])), data = test, family = "binomial"(link=logit))
    }
}

odds = fit
odds[-pcitems.temp] = lapply(fit[-pcitems.temp], predict, test[1,], type="response")
odds[pcitems.temp] = lapply(fit[pcitems.temp], predict, test[1,], type="probs")
info.temp = FUN.info.temp.IND(odds)
info.rest[1,] = sum(info.temp)

names(summe) = names(entropie)

if (exists("benchmark"))
{
    benchmark = array(c(benchmark,(proc.time() - calculationtime)[3]))
} else
{
    benchmark = (proc.time() - calculationtime)[3]
}
#+END_SRC

*** Formel für die Modellanpassung
Hier kann noch bestimmt werden, ob die binärlogistischen Regressionen noch schlechte Items verwerfen, oder einfach mit allen rechnen.
Änderungen, die hier gemacht werden, werden automatisch im gesamten Code angepasst, da dieser Teil mit noweb-syntax eingebunden ist.

Aus statistischer Sicht ist es natürlich viel besser, wenn schlechte Items noch verworfen und noch Interaktionen hinzugefügt werden.
Was hier aber dagegen spricht, ist die dadurch resultierende Berechnungsdauer.
So sind selbst die einfacheren obigen Modell auch nach Stunden nicht fertig.
#+NAME: fit
#+BEGIN_SRC R :exports code
#fit = lapply(fit, step, trace = 0)
#fit = lapply(fit, step, ~.^2, trace = 0)
#+END_SRC

*** Benchmark
#+BEGIN_SRC R :noweb yes :results output graphics :file /images/benchmark.png :exports code
plot(benchmark, type="l", col=rgb(0,0,0), ann=F)
title(xlab="Durchlauf")
title(ylab="Dauer")
#+END_SRC

#+RESULTS:
[[file:/images/benchmark.png]]

*** infografik
Hier ist noch ein letztes kleines Bisschen an Code, welches die derzeit kalkulierten Ergebnisse in eine Grafik packt.
Zudem werden eine Legende generiert und die Berechnungsdauer angegeben.
#+NAME: grafik
#+BEGIN_SRC R :noweb yes :results output graphics :file /images/entropie2.png :exports code
farbe = NULL
farbeSD = NULL
for (j in 1:(length(summe[1,])))
{
    r = runif(1,0.1,0.9)
    g = runif(1,0.1,0.9)
    b = runif(1,0.1,0.9)
    farbe[j] = rgb(r^1.2, g^1.2, b^1.2)
    farbeSD[j] = rgb(sqrt(r), sqrt(g), sqrt(b))
}

plot(0:(length(test)), type="l", col=rgb(0,0,0), ann=F)

for (i in 1:(length(summe[1,])))
{
    lines(summe[,i], col=farbe[i])
    
    if (dim(entropie.SD[names(entropie.SD) == names(summe[i])])[2] != 0)
    {
        lines(summe[,i]+entropie.SD[names(summe[i])],lty = 4, col=farbeSD[i])
        lines(summe[,i]-entropie.SD[names(summe[i])],lty = 4, col=farbeSD[i])
    }
    
    if (dim(info.rest[names(info.rest) == names(summe[i])])[2] != 0)
    {
        lines(info.rest[names(summe[i])], col=farbe[i])
        lines(info.rest[names(summe[i])]+info.rest.SD[names(summe[i])],lty = 4, col=farbeSD[i])
        lines(info.rest[names(summe[i])]-info.rest.SD[names(summe[i])],lty = 4, col=farbeSD[i])
    }
}

title(xlab="Anzahl der beantworteten Fragen")
title(ylab="Entropie in bit")
legend(length(test)/4, length(test), c(names(summe), round(benchmark[length(benchmark)])), cex=0.9, col=c(farbe, rgb(1,1,1)), lty=1)
#+END_SRC

#+RESULTS: grafik
[[file:/images/entropie2.png]]
